{"ast":null,"code":"import firebase from \"firebase/app\";\nimport \"firebase/messaging\";\nimport 'firebase/auth';\nimport 'firebase/database';\nimport storageService from \"../utils/storageService\";\nimport Constants from \"../utils/constants\";\nimport moment from 'moment';\n\nif (!firebase.apps.length) {\n  firebase.initializeApp(Constants.qaStgFirebaseConfig);\n}\n\nconst checkIfSupport = () => {\n  console.log(firebase.messaging.isSupported());\n\n  if (firebase.messaging.isSupported()) {\n    return firebase.messaging();\n  }\n\n  return false;\n};\n\nexport const auth = firebase.auth();\nexport const messaging = checkIfSupport(); //firebase.messaging();\n\nexport const db = firebase.database();\nconst CHAT_TYPE = 'single';\nconst FIREBASE_COLLECTION = {\n  ROOM_INFO: \"room_info\",\n  JOBS: \"jobs\",\n  INBOX: \"inbox\",\n  MESSAGES: \"messages\",\n  LAST_MESSAGES: \"lastMessage\",\n  USERS: \"users\"\n};\nlet loggedInuserId = \"\";\nlet msgListnerObj; // let totalPendingCounter = 0;\n\nlet inboxListner;\n\nconst getRegisterToken = () => {\n  return new Promise((resolve, reject) => {\n    messaging.getToken({\n      vapidKey: Constants.FirebasePushServiceKey\n    }).then(currentToken => {\n      if (currentToken) {\n        console.log(\"firebase token fetched successsfully\", currentToken);\n        resolve({\n          success: true,\n          deviceToken: currentToken\n        });\n      } else {\n        console.log('No registration token available.');\n        setTokenSentToServer(false);\n        resolve({\n          success: false\n        });\n      }\n    }).catch(err => {\n      console.log('An error occurred while retrieving  from firebase. ', err);\n      setTokenSentToServer(false);\n      reject({\n        success: false\n      });\n    });\n  });\n};\n\nconst setTokenSentToServer = sent => {\n  storageService.setItem('sentToServer', sent ? '1' : '0');\n  storageService.setItem('fcmToken', '');\n};\n\nconst isTokenSentToServer = () => {\n  return storageService.getItem('sentToServer') === '1';\n};\n\nexport const requestPermission = () => {\n  if (checkIfSupport()) {\n    return new Promise((resolve, reject) => {\n      Notification.requestPermission().then(permission => {\n        const data = getRegisterToken();\n        resolve(data);\n      }) // if (permission === 'granted' && isTokenSentToServer()) {\n      //     const data = getRegisterToken();\n      //     console.log('Token Already sent');\n      //     resolve(data);\n      // }\n      .catch(err => {\n        console.log('Unable to get permission to show notification browser : ', err);\n        reject({\n          success: false\n        });\n      });\n    });\n  }\n};\nexport const deleteToken = () => {\n  if (checkIfSupport()) {\n    messaging.deleteToken().then(() => {\n      console.log('firebase Token deleted.');\n    }).catch(err => {\n      console.log('Unable to delete firebase token. ', err);\n    });\n  }\n};\nexport const signOut = () => {\n  auth.signOut().then(() => {\n    console.log('Firebase signout successful.');\n  }).catch(err => {\n    console.log('Firebase sign out error.', err);\n  });\n};\nexport const firebaseSignUpWithEmailPassword = async ({\n  email,\n  password,\n  id,\n  fullName,\n  user_type\n}) => {\n  try {\n    let ref = await auth.createUserWithEmailAndPassword(email, password);\n\n    if (ref) {\n      await ref.user.updateProfile({\n        displayName: fullName // photoURL: '',\n        // roleId: user_type,\n\n      });\n      await db.ref(`${FIREBASE_COLLECTION.USERS}/${id}`).set({\n        email: email,\n        image: '',\n        name: fullName,\n        // uid: ref.user[\"$\"][\"W\"],\n        userId: id,\n        onlineStatus: true,\n        userType: user_type\n      });\n      console.log(\"firebase authentication success\");\n    }\n  } catch (err) {\n    console.log(\"firebase authentication failure: \", {\n      err\n    });\n  }\n};\nexport const firebaseLogInWithEmailPassword = async (authData, loginRes, isSignup) => {\n  console.log('authData: ', authData);\n\n  try {\n    let response = await auth.signInWithEmailAndPassword(authData.email, authData.password);\n\n    if (response) {\n      console.log('firebase auth login success: ');\n      if (isSignup) return;\n      await db.ref(`${FIREBASE_COLLECTION.USERS}/${loginRes === null || loginRes === void 0 ? void 0 : loginRes._id}`).set({\n        email: loginRes === null || loginRes === void 0 ? void 0 : loginRes.email,\n        image: loginRes === null || loginRes === void 0 ? void 0 : loginRes.user_image,\n        name: loginRes === null || loginRes === void 0 ? void 0 : loginRes.userName,\n        userId: loginRes === null || loginRes === void 0 ? void 0 : loginRes._id,\n        onlineStatus: true,\n        userType: loginRes === null || loginRes === void 0 ? void 0 : loginRes.user_type\n      });\n    }\n  } catch (err) {\n    console.log('firebase auth login failure: ');\n  }\n}; ////////////////////////  firebase chat\n\nexport const loginAnonymously = async () => {\n  let userInfo = storageService.getItem(\"userInfo\");\n\n  try {\n    let response = await auth.signInAnonymously();\n\n    if (response) {\n      console.log('firebase anonymous auth login success: ');\n      await db.ref(`${FIREBASE_COLLECTION.USERS}/${userInfo === null || userInfo === void 0 ? void 0 : userInfo._id}`).update({\n        email: userInfo === null || userInfo === void 0 ? void 0 : userInfo.email,\n        image: userInfo === null || userInfo === void 0 ? void 0 : userInfo.user_image,\n        name: userInfo === null || userInfo === void 0 ? void 0 : userInfo.userName,\n        userId: userInfo === null || userInfo === void 0 ? void 0 : userInfo._id,\n        onlineStatus: true,\n        userType: userInfo === null || userInfo === void 0 ? void 0 : userInfo.user_type,\n        deviceType: 1\n      });\n    }\n  } catch (error) {\n    console.log('firebase anonymous auth login failure: ');\n    var errorCode = error.code;\n\n    if (errorCode === 'auth/operation-not-allowed') {\n      alert('You must enable Anonymous auth in the Firebase Console.');\n    } else {\n      console.error(error);\n    }\n  }\n};\nexport const getLoggedInuserId = () => {\n  var _storageService$getIt;\n\n  return (_storageService$getIt = storageService.getItem(\"userInfo\")) === null || _storageService$getIt === void 0 ? void 0 : _storageService$getIt._id;\n};\nexport const updateChatUserDetails = async (updateType, value) => {\n  let loggedInuserId = getLoggedInuserId();\n\n  try {\n    await db.ref(`${FIREBASE_COLLECTION.USERS}/${loggedInuserId}`).update({ ...(updateType === 'userImage' && {\n        image: value\n      }),\n      ...(updateType === 'userName' && {\n        name: value\n      }),\n      ...(updateType === 'deviceToken' && {\n        deviceToken: value\n      }),\n      ...(updateType === 'isNotification' && {\n        isNotification: value\n      })\n    });\n    console.log(`firebase ${updateType} update success`);\n  } catch (err) {\n    console.log(`firebase ${updateType} update failure: `, {\n      err\n    });\n  }\n};\nexport const createRoom = async (jobId, tradieId, builderId, jobName) => {\n  let loggedInuserId = getLoggedInuserId();\n  const roomID = `${jobId}_${tradieId}_${builderId}`;\n\n  if (await checkRoomExist(roomID)) {\n    return;\n  }\n\n  let roomInfoObj = {\n    id: roomID,\n    chatRoomType: CHAT_TYPE,\n    chatLastUpdate: firebase.database.ServerValue.TIMESTAMP\n  };\n  let chatLastUpdates = {};\n  chatLastUpdates[tradieId] = tradieId === loggedInuserId ? firebase.database.ServerValue.TIMESTAMP : 0;\n  chatLastUpdates[loggedInuserId] = firebase.database.ServerValue.TIMESTAMP;\n  let chatRoomMembers = {};\n  chatRoomMembers[tradieId] = {\n    memberDelete: firebase.database.ServerValue.TIMESTAMP,\n    memberJoin: firebase.database.ServerValue.TIMESTAMP,\n    memberLeave: 0\n  };\n  chatRoomMembers[builderId] = {\n    memberDelete: firebase.database.ServerValue.TIMESTAMP,\n    memberJoin: firebase.database.ServerValue.TIMESTAMP,\n    memberLeave: 0\n  };\n  roomInfoObj.chatRoomMembers = chatRoomMembers;\n  roomInfoObj.chatLastUpdates = chatLastUpdates;\n  await db.ref(`${FIREBASE_COLLECTION.ROOM_INFO}/${roomID}/`).set(roomInfoObj); // debugger;\n  // await createItem(itemInfo);\n  //loggedin user inbox\n\n  await createInbox(tradieId, roomID, jobId, builderId, jobName); // opposite user inbox\n\n  await createInbox(builderId, roomID, jobId, tradieId, jobName);\n  return roomInfoObj;\n};\nexport const checkRoomExist = async roomID => {\n  let room = await db.ref(`${FIREBASE_COLLECTION.ROOM_INFO}/${roomID}/`).once('value');\n  return room.exists();\n};\nexport const createJob = async jobInfo => {\n  await db.ref(`${FIREBASE_COLLECTION.JOBS}/${jobInfo.jobId}/`).set(jobInfo);\n};\nexport const createInbox = async (userid, roomId, jobId, oppuserid, jobName) => {\n  const inboxKey = `${oppuserid}_${jobId}`;\n  await db.ref(`${FIREBASE_COLLECTION.INBOX}/${userid}/${inboxKey}`).set({\n    jobId: jobId,\n    jobName: jobName,\n    roomId: roomId,\n    unreadMessages: 0\n  });\n};\nexport const getFirebaseInboxData = async listner => {\n  // debugger;\n  let userId = getLoggedInuserId();\n\n  if (!userId) {\n    listner([]);\n    return;\n  }\n\n  let dbRef = `${FIREBASE_COLLECTION.INBOX}/${userId}`;\n  console.log(\"getFirebaseIndexData\", dbRef);\n\n  if (inboxListner) {\n    db.ref(dbRef).off();\n    db.ref(dbRef).off('value', msgListnerObj);\n  }\n\n  inboxListner = db.ref(dbRef).on(\"value\", async snapshot => {\n    let indexlist = [];\n    snapshot.forEach(snap => {\n      indexlist.push(snap.val());\n    });\n    let items = [];\n    let users = [];\n\n    for (let i = 0; i < indexlist.length; i++) {\n      // let itemIndex = items.findIndex((item) => item.jobId === indexlist[i].jobId);\n      // if (itemIndex == -1) {\n      //     let room = await db.ref(`${FIREBASE_COLLECTION.JOBS}/${indexlist[i].jobId}`).once('value');\n      //     if (room.exists()) {\n      //         let lastMsg = await db.ref(`${FIREBASE_COLLECTION.LAST_MESSAGES}/${indexlist[i].roomId}/chatLastMessage`).once('value');\n      //         indexlist[i].item = room.val();\n      //         if (lastMsg.exists())\n      //             indexlist[i].lastMsg = lastMsg.val();\n      //         items.push(room.val());\n      //     }\n      // } else {\n      //     indexlist[i].item = items[itemIndex];\n      // }\n      let lastMsg = await db.ref(`${FIREBASE_COLLECTION.LAST_MESSAGES}/${indexlist[i].roomId}/chatLastMessage`).once('value');\n\n      if (lastMsg.exists()) {\n        indexlist[i].lastMsg = lastMsg.val();\n      }\n\n      let oppUserId = '';\n\n      if (storageService.getItem('userType') === 1) {\n        oppUserId = indexlist[i].roomId.split('_')[2];\n      } else {\n        oppUserId = indexlist[i].roomId.split('_')[1];\n      }\n\n      let userIndex = users.findIndex(item => item.userId === oppUserId);\n\n      if (userIndex == -1) {\n        let oppUserInfo = await db.ref(`${FIREBASE_COLLECTION.USERS}/${oppUserId}`).once('value');\n\n        if (oppUserInfo.exists()) {\n          indexlist[i].oppUserInfo = oppUserInfo.val();\n          users.push(oppUserInfo.val());\n        }\n      } else {\n        indexlist[i].oppUserInfo = users[userIndex];\n      }\n    }\n\n    setPendingCounter(indexlist);\n    await listner(indexlist);\n  });\n};\nexport const setPendingCounter = indexlist => {\n  let count = 0;\n  let unreadMsg = indexlist.filter(d => d.unreadMessages > 0);\n  unreadMsg.length === 0 ? count = 0 : count = unreadMsg.length; // store.dispatch({\n  //     type: INBOX_COUNTER_SET,\n  //     payLoad: count\n  // });\n}; // export const getFirebaseItemsData = async () => {\n//     let itemlist = [];\n//     db.ref(`${FIREBASE_COLLECTION.JOBS}`).on(\"value\", (snapshot) => {\n//         snapshot.forEach((snap) => {\n//             itemlist.push(snap.val());\n//         });\n//     });\n//     return itemlist;\n// }\n// export const getFirebaseRoomInfoData = async () => {\n//     let roomlist = [];\n//     db.ref(`${FIREBASE_COLLECTION.ROOM_INFO}`).on(\"value\", (snapshot) => {\n//         snapshot.forEach((snap) => {\n//             roomlist.push(snap.val());\n//         });\n//     });\n//     return roomlist\n// }\n\nexport const getMessagesOfRoom = async (roomId, listner) => {\n  //getPreviousMessages check KT file\n  //.limitToLast(10)\n  // if (msgListnerObj) {\n  //     await db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`).off('value', msgListnerObj);\n  // }\n  msgListnerObj = db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`).orderByChild('messageTimestamp').limitToLast(500).on(\"value\", snapshot => {\n    let itemlist = [];\n    snapshot.forEach(snap => {\n      itemlist.push(snap.val());\n    });\n    listner(itemlist);\n  });\n};\nexport const stopListeningOfRoom = async roomId => {\n  if (msgListnerObj) {\n    db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`).off('value', msgListnerObj);\n    db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`).off();\n  }\n\n  console.log(\"Stop listening Of Room\");\n};\nexport const sendTextMessage = async (roomId, message) => {\n  let senderId = getLoggedInuserId();\n  let roomids = roomId.split(\"_\");\n  let jobId = \"\";\n  let receiverId = \"\";\n\n  if (roomids.length == 3) {\n    if (roomids[1] == senderId) {\n      receiverId = roomids[2];\n    } else {\n      receiverId = roomids[1];\n    }\n\n    jobId = roomids[0];\n  }\n\n  let dbRef = db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`);\n  const newMsgRef = dbRef.push(); // Get the unique key generated by push()\n\n  const messageID = newMsgRef.key;\n  let msgData = {\n    \"isBlock\": false,\n    \"isDeleted\": false,\n    \"mediaDuration\": \"\",\n    \"mediaUrl\": \"\",\n    \"messageCaption\": \"\",\n    \"messageId\": messageID,\n    \"messageRoomId\": roomId,\n    \"messageStatus\": \"send\",\n    \"messageText\": message,\n    \"messageTimestamp\": firebase.database.ServerValue.TIMESTAMP,\n    \"messageType\": \"text\",\n    \"progress\": 0,\n    \"receiverId\": receiverId,\n    \"senderId\": senderId,\n    \"thumbnail\": \"\"\n  };\n  await db.ref(`${FIREBASE_COLLECTION.LAST_MESSAGES}/${roomId}/chatLastMessage`).set(msgData);\n  await db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}/${messageID}`).set(msgData);\n  msgData.messageTimestamp = moment().toDate().getTime(); //TODO Implement Update Message Counter\n  //https://stackoverflow.com/questions/42276881/increment-firebase-value-from-javascript-subject-to-constraint\n\n  let inboxId = `${senderId}_${jobId}`;\n  await db.ref(`${FIREBASE_COLLECTION.INBOX}/${receiverId}/${inboxId}`).child('unreadMessages').set(firebase.database.ServerValue.increment(1));\n  return msgData;\n};\nexport const sendImageVideoMessage = async (roomId, url, type) => {\n  let senderId = getLoggedInuserId();\n  let roomids = roomId.split(\"_\");\n  let jobId = \"\";\n  let receiverId = \"\";\n\n  if (roomids.length == 3) {\n    if (roomids[1] == senderId) {\n      receiverId = roomids[2];\n    } else {\n      receiverId = roomids[1];\n    }\n\n    jobId = roomids[0];\n  }\n\n  let dbRef = db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`);\n  const newMsgRef = dbRef.push(); // Get the unique key generated by push()\n\n  const messageID = newMsgRef.key;\n  let msgData = {\n    \"isBlock\": false,\n    \"isDeleted\": false,\n    \"mediaDuration\": \"\",\n    \"mediaUrl\": url,\n    \"messageCaption\": \"\",\n    \"messageId\": messageID,\n    \"messageRoomId\": roomId,\n    \"messageStatus\": \"send\",\n    \"messageText\": \"\",\n    \"messageTimestamp\": firebase.database.ServerValue.TIMESTAMP,\n    \"messageType\": type === \"image\" ? \"image\" : \"video\",\n    \"progress\": 0,\n    \"receiverId\": receiverId,\n    \"senderId\": senderId,\n    \"thumbnail\": url\n  };\n  await db.ref(`${FIREBASE_COLLECTION.LAST_MESSAGES}/${roomId}/chatLastMessage`).set(msgData);\n  await db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}/${messageID}`).set(msgData);\n  msgData.messageTimestamp = moment().toDate().getTime(); //Implement Update Message Counter\n  //https://stackoverflow.com/questions/42276881/increment-firebase-value-from-javascript-subject-to-constraint\n\n  let inboxId = `${senderId}_${jobId}`;\n  await db.ref(`${FIREBASE_COLLECTION.INBOX}/${receiverId}/${inboxId}`).child('unreadMessages').set(firebase.database.ServerValue.increment(1));\n  return msgData;\n};\nexport const resetUnreadCounter = async roomId => {\n  let senderId = getLoggedInuserId();\n  let roomids = roomId.split(\"_\");\n  let jobId = \"\";\n  let receiverId = \"\";\n\n  if (roomids.length === 3) {\n    if (roomids[1] == senderId) {\n      receiverId = roomids[2];\n    } else {\n      receiverId = roomids[1];\n    }\n\n    jobId = roomids[0];\n  }\n\n  let inboxId = `${receiverId}_${jobId}`;\n  await db.ref(`${FIREBASE_COLLECTION.INBOX}/${senderId}/${inboxId}`).child('unreadMessages').set(0);\n};\nexport default firebase;","map":{"version":3,"sources":["/home/appinventiv/Documents/Project/tickt/web/src/services/firebase.js"],"names":["firebase","storageService","Constants","moment","apps","length","initializeApp","qaStgFirebaseConfig","checkIfSupport","console","log","messaging","isSupported","auth","db","database","CHAT_TYPE","FIREBASE_COLLECTION","ROOM_INFO","JOBS","INBOX","MESSAGES","LAST_MESSAGES","USERS","loggedInuserId","msgListnerObj","inboxListner","getRegisterToken","Promise","resolve","reject","getToken","vapidKey","FirebasePushServiceKey","then","currentToken","success","deviceToken","setTokenSentToServer","catch","err","sent","setItem","isTokenSentToServer","getItem","requestPermission","Notification","permission","data","deleteToken","signOut","firebaseSignUpWithEmailPassword","email","password","id","fullName","user_type","ref","createUserWithEmailAndPassword","user","updateProfile","displayName","set","image","name","userId","onlineStatus","userType","firebaseLogInWithEmailPassword","authData","loginRes","isSignup","response","signInWithEmailAndPassword","_id","user_image","userName","loginAnonymously","userInfo","signInAnonymously","update","deviceType","error","errorCode","code","alert","getLoggedInuserId","updateChatUserDetails","updateType","value","isNotification","createRoom","jobId","tradieId","builderId","jobName","roomID","checkRoomExist","roomInfoObj","chatRoomType","chatLastUpdate","ServerValue","TIMESTAMP","chatLastUpdates","chatRoomMembers","memberDelete","memberJoin","memberLeave","createInbox","room","once","exists","createJob","jobInfo","userid","roomId","oppuserid","inboxKey","unreadMessages","getFirebaseInboxData","listner","dbRef","off","on","snapshot","indexlist","forEach","snap","push","val","items","users","i","lastMsg","oppUserId","split","userIndex","findIndex","item","oppUserInfo","setPendingCounter","count","unreadMsg","filter","d","getMessagesOfRoom","orderByChild","limitToLast","itemlist","stopListeningOfRoom","sendTextMessage","message","senderId","roomids","receiverId","newMsgRef","messageID","key","msgData","messageTimestamp","toDate","getTime","inboxId","child","increment","sendImageVideoMessage","url","type","resetUnreadCounter"],"mappings":"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","sourcesContent":["import firebase from \"firebase/app\";\nimport \"firebase/messaging\";\nimport 'firebase/auth';\nimport 'firebase/database';\nimport storageService from \"../utils/storageService\";\nimport Constants from \"../utils/constants\";\nimport moment from 'moment';\n\nif (!firebase.apps.length) {\n    firebase.initializeApp(Constants.qaStgFirebaseConfig);\n}\n\nconst checkIfSupport = () => {\n    console.log(firebase.messaging.isSupported());\n    if (firebase.messaging.isSupported()) {\n        return firebase.messaging();\n    }\n    return false;\n}\n\nexport const auth = firebase.auth();\nexport const messaging = checkIfSupport(); //firebase.messaging();\nexport const db = firebase.database();\n\nconst CHAT_TYPE = 'single';\nconst FIREBASE_COLLECTION = {\n    ROOM_INFO: \"room_info\",\n    JOBS: \"jobs\",\n    INBOX: \"inbox\",\n    MESSAGES: \"messages\",\n    LAST_MESSAGES: \"lastMessage\",\n    USERS: \"users\",\n}\nlet loggedInuserId = \"\";\nlet msgListnerObj;\n// let totalPendingCounter = 0;\nlet inboxListner;\n\n\nconst getRegisterToken = () => {\n    return new Promise((resolve, reject) => {\n        messaging.getToken({\n            vapidKey: Constants.FirebasePushServiceKey\n        }).then((currentToken) => {\n            if (currentToken) {\n                console.log(\"firebase token fetched successsfully\", currentToken);\n                resolve({ success: true, deviceToken: currentToken });\n            } else {\n                console.log('No registration token available.');\n                setTokenSentToServer(false);\n                resolve({ success: false });\n            }\n        }).catch((err) => {\n            console.log('An error occurred while retrieving  from firebase. ', err);\n            setTokenSentToServer(false);\n            reject({ success: false });\n        });\n    })\n}\n\nconst setTokenSentToServer = (sent) => {\n    storageService.setItem('sentToServer', sent ? '1' : '0');\n    storageService.setItem('fcmToken', '');\n}\n\nconst isTokenSentToServer = () => {\n    return storageService.getItem('sentToServer') === '1';\n}\n\nexport const requestPermission = () => {\n    if (checkIfSupport()) {\n        return new Promise((resolve, reject) => {\n            Notification.requestPermission().then((permission) => {\n                const data = getRegisterToken();\n                resolve(data);\n            })\n                // if (permission === 'granted' && isTokenSentToServer()) {\n                //     const data = getRegisterToken();\n                //     console.log('Token Already sent');\n                //     resolve(data);\n                // }\n                .catch((err) => {\n                    console.log('Unable to get permission to show notification browser : ', err);\n                    reject({ success: false });\n                });\n        })\n    }\n}\n\nexport const deleteToken = () => {\n    if (checkIfSupport()) {\n        messaging.deleteToken().then(() => {\n            console.log('firebase Token deleted.');\n        }).catch((err) => {\n            console.log('Unable to delete firebase token. ', err);\n        });\n    }\n}\n\nexport const signOut = () => {\n    auth.signOut().then(() => {\n        console.log('Firebase signout successful.');\n    }).catch((err) => {\n        console.log('Firebase sign out error.', err);\n    });\n}\n\nexport const firebaseSignUpWithEmailPassword = async ({ email, password, id, fullName, user_type }) => {\n    try {\n        let ref = await auth.createUserWithEmailAndPassword(email, password);\n        if (ref) {\n            await ref.user.updateProfile({\n                displayName: fullName,\n                // photoURL: '',\n                // roleId: user_type,\n            });\n\n            await db.ref(`${FIREBASE_COLLECTION.USERS}/${id}`).set({\n                email: email,\n                image: '',\n                name: fullName,\n                // uid: ref.user[\"$\"][\"W\"],\n                userId: id,\n                onlineStatus: true,\n                userType: user_type,\n            });\n            console.log(\"firebase authentication success\")\n        }\n    } catch (err) {\n        console.log(\"firebase authentication failure: \", { err });\n    }\n};\n\nexport const firebaseLogInWithEmailPassword = async (authData, loginRes, isSignup) => {\n    console.log('authData: ', authData);\n    try {\n        let response = await auth.signInWithEmailAndPassword(authData.email, authData.password);\n        if (response) {\n            console.log('firebase auth login success: ');\n            if (isSignup) return;\n            await db.ref(`${FIREBASE_COLLECTION.USERS}/${loginRes?._id}`).set({\n                email: loginRes?.email,\n                image: loginRes?.user_image,\n                name: loginRes?.userName,\n                userId: loginRes?._id,\n                onlineStatus: true,\n                userType: loginRes?.user_type,\n            });\n        }\n    } catch (err) {\n        console.log('firebase auth login failure: ');\n    }\n}\n\n////////////////////////  firebase chat\n\nexport const loginAnonymously = async () => {\n    let userInfo = storageService.getItem(\"userInfo\");\n    try {\n        let response = await auth.signInAnonymously();\n        if (response) {\n            console.log('firebase anonymous auth login success: ');\n            await db.ref(`${FIREBASE_COLLECTION.USERS}/${userInfo?._id}`).update({\n                email: userInfo?.email,\n                image: userInfo?.user_image,\n                name: userInfo?.userName,\n                userId: userInfo?._id,\n                onlineStatus: true,\n                userType: userInfo?.user_type,\n                deviceType: 1\n            });\n        }\n    } catch (error) {\n        console.log('firebase anonymous auth login failure: ');\n        var errorCode = error.code;\n        if (errorCode === 'auth/operation-not-allowed') {\n            alert('You must enable Anonymous auth in the Firebase Console.');\n        } else {\n            console.error(error);\n        }\n    }\n}\n\nexport const getLoggedInuserId = () => {\n    return storageService.getItem(\"userInfo\")?._id;\n}\n\nexport const updateChatUserDetails = async (updateType, value) => {\n    let loggedInuserId = getLoggedInuserId();\n    try {\n        await db.ref(`${FIREBASE_COLLECTION.USERS}/${loggedInuserId}`).update({\n            ...(updateType === 'userImage' && { image: value }),\n            ...(updateType === 'userName' && { name: value }),\n            ...(updateType === 'deviceToken' && { deviceToken: value }),\n            ...(updateType === 'isNotification' && { isNotification: value }),\n        });\n        console.log(`firebase ${updateType} update success`);\n    } catch (err) {\n        console.log(`firebase ${updateType} update failure: `, { err });\n    }\n}\n\nexport const createRoom = async (jobId, tradieId, builderId, jobName) => {\n    let loggedInuserId = getLoggedInuserId();\n\n    const roomID = `${jobId}_${tradieId}_${builderId}`;\n\n    if (await checkRoomExist(roomID)) {\n        return;\n    }\n\n    let roomInfoObj = {\n        id: roomID,\n        chatRoomType: CHAT_TYPE,\n        chatLastUpdate: firebase.database.ServerValue.TIMESTAMP,\n    };\n    let chatLastUpdates = {};\n    chatLastUpdates[tradieId] = tradieId === loggedInuserId ? firebase.database.ServerValue.TIMESTAMP : 0;\n    chatLastUpdates[loggedInuserId] = firebase.database.ServerValue.TIMESTAMP;\n\n    let chatRoomMembers = {};\n    chatRoomMembers[tradieId] = {\n        memberDelete: firebase.database.ServerValue.TIMESTAMP,\n        memberJoin: firebase.database.ServerValue.TIMESTAMP,\n        memberLeave: 0\n    }\n\n    chatRoomMembers[builderId] = {\n        memberDelete: firebase.database.ServerValue.TIMESTAMP,\n        memberJoin: firebase.database.ServerValue.TIMESTAMP,\n        memberLeave: 0\n    }\n    roomInfoObj.chatRoomMembers = chatRoomMembers;\n    roomInfoObj.chatLastUpdates = chatLastUpdates;\n\n    await db.ref(`${FIREBASE_COLLECTION.ROOM_INFO}/${roomID}/`).set(roomInfoObj);\n    // debugger;\n    // await createItem(itemInfo);\n    //loggedin user inbox\n    await createInbox(tradieId, roomID, jobId, builderId, jobName);\n    // opposite user inbox\n    await createInbox(builderId, roomID, jobId, tradieId, jobName);\n    return roomInfoObj;\n}\n\nexport const checkRoomExist = async (roomID) => {\n    let room = await db.ref(`${FIREBASE_COLLECTION.ROOM_INFO}/${roomID}/`).once('value');\n    return room.exists();\n}\n\nexport const createJob = async (jobInfo) => {\n    await db.ref(`${FIREBASE_COLLECTION.JOBS}/${jobInfo.jobId}/`).set(jobInfo);\n}\n\nexport const createInbox = async (userid, roomId, jobId, oppuserid, jobName) => {\n    const inboxKey = `${oppuserid}_${jobId}`;\n    await db.ref(`${FIREBASE_COLLECTION.INBOX}/${userid}/${inboxKey}`).set({\n        jobId: jobId,\n        jobName: jobName,\n        roomId: roomId,\n        unreadMessages: 0\n    });\n}\n\nexport const getFirebaseInboxData = async (listner) => {\n    // debugger;\n    let userId = getLoggedInuserId();\n    if (!userId) {\n        listner([]);\n        return;\n    }\n    let dbRef = `${FIREBASE_COLLECTION.INBOX}/${userId}`;\n    console.log(\"getFirebaseIndexData\", dbRef);\n    if (inboxListner) {\n        db.ref(dbRef).off();\n        db.ref(dbRef).off('value', msgListnerObj);\n    }\n    inboxListner = db.ref(dbRef).on(\"value\", async (snapshot) => {\n        let indexlist = [];\n        snapshot.forEach((snap) => {\n            indexlist.push(snap.val());\n        });\n        let items = [];\n        let users = [];\n        for (let i = 0; i < indexlist.length; i++) {\n            // let itemIndex = items.findIndex((item) => item.jobId === indexlist[i].jobId);\n            // if (itemIndex == -1) {\n            //     let room = await db.ref(`${FIREBASE_COLLECTION.JOBS}/${indexlist[i].jobId}`).once('value');\n            //     if (room.exists()) {\n            //         let lastMsg = await db.ref(`${FIREBASE_COLLECTION.LAST_MESSAGES}/${indexlist[i].roomId}/chatLastMessage`).once('value');\n            //         indexlist[i].item = room.val();\n            //         if (lastMsg.exists())\n            //             indexlist[i].lastMsg = lastMsg.val();\n            //         items.push(room.val());\n            //     }\n            // } else {\n            //     indexlist[i].item = items[itemIndex];\n            // }\n            let lastMsg = await db.ref(`${FIREBASE_COLLECTION.LAST_MESSAGES}/${indexlist[i].roomId}/chatLastMessage`).once('value');\n            if (lastMsg.exists()) {\n                indexlist[i].lastMsg = lastMsg.val();\n            }\n            let oppUserId = '';\n            if (storageService.getItem('userType') === 1) {\n                oppUserId = indexlist[i].roomId.split('_')[2];\n            } else {\n                oppUserId = indexlist[i].roomId.split('_')[1];\n            }\n            let userIndex = users.findIndex((item) => item.userId === oppUserId);\n            if (userIndex == -1) {\n                let oppUserInfo = await db.ref(`${FIREBASE_COLLECTION.USERS}/${oppUserId}`).once('value');\n                if (oppUserInfo.exists()) {\n                    indexlist[i].oppUserInfo = oppUserInfo.val();\n                    users.push(oppUserInfo.val());\n                }\n            } else {\n                indexlist[i].oppUserInfo = users[userIndex];\n            }\n        }\n        setPendingCounter(indexlist);\n        await listner(indexlist);\n    });\n}\n\nexport const setPendingCounter = (indexlist) => {\n    let count = 0;\n    let unreadMsg = indexlist.filter((d) => d.unreadMessages > 0)\n    unreadMsg.length === 0 ? count = 0 : count = unreadMsg.length\n    // store.dispatch({\n    //     type: INBOX_COUNTER_SET,\n    //     payLoad: count\n    // });\n}\n\n// export const getFirebaseItemsData = async () => {\n//     let itemlist = [];\n//     db.ref(`${FIREBASE_COLLECTION.JOBS}`).on(\"value\", (snapshot) => {\n//         snapshot.forEach((snap) => {\n//             itemlist.push(snap.val());\n//         });\n//     });\n//     return itemlist;\n// }\n\n// export const getFirebaseRoomInfoData = async () => {\n//     let roomlist = [];\n//     db.ref(`${FIREBASE_COLLECTION.ROOM_INFO}`).on(\"value\", (snapshot) => {\n//         snapshot.forEach((snap) => {\n//             roomlist.push(snap.val());\n//         });\n//     });\n//     return roomlist\n// }\n\nexport const getMessagesOfRoom = async (roomId, listner) => {\n    //getPreviousMessages check KT file\n    //.limitToLast(10)\n\n    // if (msgListnerObj) {\n    //     await db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`).off('value', msgListnerObj);\n    // }\n\n    msgListnerObj = db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`).orderByChild('messageTimestamp').limitToLast(500).on(\"value\", (snapshot) => {\n        let itemlist = [];\n        snapshot.forEach((snap) => {\n            itemlist.push(snap.val());\n        });\n        listner(itemlist);\n    });\n}\n\nexport const stopListeningOfRoom = async (roomId) => {\n\n    if (msgListnerObj) {\n        db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`).off('value', msgListnerObj);\n        db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`).off();\n    }\n    console.log(\"Stop listening Of Room\");\n}\n\nexport const sendTextMessage = async (roomId, message) => {\n    let senderId = getLoggedInuserId();\n    let roomids = roomId.split(\"_\");\n    let jobId = \"\";\n    let receiverId = \"\";\n    if (roomids.length == 3) {\n        if (roomids[1] == senderId) {\n            receiverId = roomids[2];\n        } else {\n            receiverId = roomids[1];\n        }\n        jobId = roomids[0];\n    }\n\n    let dbRef = db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`);\n    const newMsgRef = dbRef.push();\n    // Get the unique key generated by push()\n    const messageID = newMsgRef.key;\n\n    let msgData = {\n        \"isBlock\": false,\n        \"isDeleted\": false,\n        \"mediaDuration\": \"\",\n        \"mediaUrl\": \"\",\n        \"messageCaption\": \"\",\n        \"messageId\": messageID,\n        \"messageRoomId\": roomId,\n        \"messageStatus\": \"send\",\n        \"messageText\": message,\n        \"messageTimestamp\": firebase.database.ServerValue.TIMESTAMP,\n        \"messageType\": \"text\",\n        \"progress\": 0,\n        \"receiverId\": receiverId,\n        \"senderId\": senderId,\n        \"thumbnail\": \"\"\n    };\n    await db.ref(`${FIREBASE_COLLECTION.LAST_MESSAGES}/${roomId}/chatLastMessage`).set(msgData);\n    await db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}/${messageID}`).set(msgData);\n    msgData.messageTimestamp = moment().toDate().getTime();\n\n    //TODO Implement Update Message Counter\n    //https://stackoverflow.com/questions/42276881/increment-firebase-value-from-javascript-subject-to-constraint\n    let inboxId = `${senderId}_${jobId}`;\n    await db.ref(`${FIREBASE_COLLECTION.INBOX}/${receiverId}/${inboxId}`).child('unreadMessages').set(firebase.database.ServerValue.increment(1));\n    return msgData;\n}\n\nexport const sendImageVideoMessage = async (roomId, url, type) => {\n    let senderId = getLoggedInuserId();\n    let roomids = roomId.split(\"_\");\n    let jobId = \"\";\n    let receiverId = \"\";\n    if (roomids.length == 3) {\n        if (roomids[1] == senderId) {\n            receiverId = roomids[2];\n        } else {\n            receiverId = roomids[1];\n        }\n        jobId = roomids[0];\n    }\n\n    let dbRef = db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`);\n    const newMsgRef = dbRef.push();\n    // Get the unique key generated by push()\n    const messageID = newMsgRef.key;\n\n    let msgData = {\n        \"isBlock\": false,\n        \"isDeleted\": false,\n        \"mediaDuration\": \"\",\n        \"mediaUrl\": url,\n        \"messageCaption\": \"\",\n        \"messageId\": messageID,\n        \"messageRoomId\": roomId,\n        \"messageStatus\": \"send\",\n        \"messageText\": \"\",\n        \"messageTimestamp\": firebase.database.ServerValue.TIMESTAMP,\n        \"messageType\": type === \"image\" ? \"image\" : \"video\",\n        \"progress\": 0,\n        \"receiverId\": receiverId,\n        \"senderId\": senderId,\n        \"thumbnail\": url\n    };\n    await db.ref(`${FIREBASE_COLLECTION.LAST_MESSAGES}/${roomId}/chatLastMessage`).set(msgData);\n    await db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}/${messageID}`).set(msgData);\n    msgData.messageTimestamp = moment().toDate().getTime();\n\n    //Implement Update Message Counter\n    //https://stackoverflow.com/questions/42276881/increment-firebase-value-from-javascript-subject-to-constraint\n    let inboxId = `${senderId}_${jobId}`;\n    await db.ref(`${FIREBASE_COLLECTION.INBOX}/${receiverId}/${inboxId}`).child('unreadMessages').set(firebase.database.ServerValue.increment(1));\n    return msgData;\n}\n\nexport const resetUnreadCounter = async (roomId) => {\n    let senderId = getLoggedInuserId();\n    let roomids = roomId.split(\"_\");\n    let jobId = \"\";\n    let receiverId = \"\";\n    if (roomids.length === 3) {\n        if (roomids[1] == senderId) {\n            receiverId = roomids[2];\n        } else {\n            receiverId = roomids[1];\n        }\n        jobId = roomids[0];\n    }\n    let inboxId = `${receiverId}_${jobId}`;\n    await db.ref(`${FIREBASE_COLLECTION.INBOX}/${senderId}/${inboxId}`).child('unreadMessages').set(0);\n}\n\nexport default firebase;"]},"metadata":{},"sourceType":"module"}