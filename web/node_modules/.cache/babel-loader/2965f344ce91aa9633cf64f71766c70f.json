{"ast":null,"code":"import { get } from 'lodash';\nimport { setShowToast } from '../redux/common/actions';\nimport storageService from '../utils/storageService';\nimport { urlFor } from './Urls';\nimport * as moment from 'moment';\nimport 'moment-timezone';\n\nclass NetworkOps {\n  constructor() {\n    this.postToJson = async (service, data) => {\n      try {\n        const JSONData = JSON.stringify(data);\n        return this.postRaw(service, JSONData);\n      } catch (err) {\n        throw err;\n      }\n    };\n\n    this.postRaw = async (service, data, options) => {\n      try {\n        const request = await this.getRequest('POST', options);\n        request.body = data;\n        return this.wrapperWithOptions(urlFor(service), request);\n      } catch (err) {\n        throw err;\n      }\n    };\n\n    this.putToJson = async (service, data) => {\n      try {\n        const request = await this.getRequest('PUT');\n        request.body = JSON.stringify(data);\n        return this.wrapperWithOptions(urlFor(service), request);\n      } catch (err) {\n        throw err;\n      }\n    };\n\n    this.get = async service => {\n      try {\n        const request = await this.getRequest('GET');\n        return await this.wrapperWithOptions(urlFor(service), request);\n      } catch (err) {\n        throw err;\n      }\n    };\n\n    this.delete = async (service, data) => {\n      try {\n        const request = await this.getRequest('DELETE');\n        request.body = JSON.stringify(data);\n        return this.wrapperWithOptions(urlFor(service), request);\n      } catch (err) {\n        throw err;\n      }\n    };\n\n    this.getRaw = async service => {\n      try {\n        const request = await this.getRequest('GET');\n        return this.wrapperWithOptions(service, request);\n      } catch (err) {\n        throw err;\n      }\n    };\n  }\n\n  async getRequest(type, options) {\n    const headerOverrides = get(options, 'headerOverrides', {});\n    const request = {\n      method: type,\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Basic dGlja3RfYXBwOnRpY2t0X2FwcF8xMjNzYWRlZnNz`,\n        'timezone': moment.tz.guess(),\n        ...headerOverrides\n      }\n    }; //if giving multipart/form-data in Content-Type: giving boundary error\n    //if also adding boundary: loader continues from server end \n\n    const token = storageService.getItem('jwtToken');\n\n    if (headerOverrides['Content-Type'] === 'multipart/form-data') {\n      delete request.headers['Content-Type'];\n    }\n\n    if (token) {\n      request.headers = { ...request.headers,\n        Authorization: token,\n        'timezone': moment.tz.guess() // Authorization: `Bearer ${token}`,\n\n      };\n    }\n\n    return request;\n  }\n\n  async wrapperWithOptions(url, request) {\n    try {\n      const response = await fetch(url, request);\n\n      if (!response.ok) {\n        if (response.status === 401) {\n          if (storageService.getItem('jwtToken')) {\n            storageService.clearAll(); // alert('Token Expired');\n\n            const res1 = await response.text();\n            const res2 = JSON.parse(res1);\n            setShowToast(true, res2.message || 'You\\'ve been logged out');\n            setTimeout(() => {\n              window.location.pathname = '/login';\n            }, 1000);\n            return;\n          }\n        } else if (response.status === 500 || response.status === 400) {\n          console.log('Got 401, now calling logout', response);\n        }\n\n        const err = await response.json();\n        console.log('Error -> ', err);\n        throw err;\n      } else {\n        const res = await response.text();\n\n        try {\n          return JSON.parse(res);\n        } catch {\n          return res;\n        }\n      }\n    } catch (error) {\n      console.log('Error', error);\n      return error;\n    }\n  }\n\n}\n\nexport default new NetworkOps();","map":{"version":3,"sources":["/home/appinventiv/Documents/Project/tickt/web/src/network/NetworkOps.ts"],"names":["get","setShowToast","storageService","urlFor","moment","NetworkOps","postToJson","service","data","JSONData","JSON","stringify","postRaw","err","options","request","getRequest","body","wrapperWithOptions","putToJson","delete","getRaw","type","headerOverrides","method","headers","Authorization","tz","guess","token","getItem","url","response","fetch","ok","status","clearAll","res1","text","res2","parse","message","setTimeout","window","location","pathname","console","log","json","res","error"],"mappings":"AAAA,SAASA,GAAT,QAAoB,QAApB;AACA,SAASC,YAAT,QAA6B,yBAA7B;AACA,OAAOC,cAAP,MAA2B,yBAA3B;AACA,SAASC,MAAT,QAAuB,QAAvB;AACA,OAAO,KAAKC,MAAZ,MAAwB,QAAxB;AACA,OAAO,iBAAP;;AAUA,MAAMC,UAAN,CAAiB;AAAA;AAAA,SAuEbC,UAvEa,GAuEA,OAAOC,OAAP,EAAwBC,IAAxB,KAA8D;AACvE,UAAI;AACA,cAAMC,QAAQ,GAAGC,IAAI,CAACC,SAAL,CAAeH,IAAf,CAAjB;AACA,eAAO,KAAKI,OAAL,CAAaL,OAAb,EAAsBE,QAAtB,CAAP;AACH,OAHD,CAIA,OAAOI,GAAP,EAAY;AACR,cAAMA,GAAN;AACH;AACJ,KA/EY;;AAAA,SAiFbD,OAjFa,GAiFH,OAAOL,OAAP,EAAwBC,IAAxB,EAAmCM,OAAnC,KAA6E;AACnF,UAAI;AACA,cAAMC,OAAO,GAAG,MAAM,KAAKC,UAAL,CAAgB,MAAhB,EAAwBF,OAAxB,CAAtB;AACAC,QAAAA,OAAO,CAACE,IAAR,GAAeT,IAAf;AACA,eAAO,KAAKU,kBAAL,CAAwBf,MAAM,CAACI,OAAD,CAA9B,EAAyCQ,OAAzC,CAAP;AACH,OAJD,CAKA,OAAOF,GAAP,EAAY;AACR,cAAMA,GAAN;AACH;AACJ,KA1FY;;AAAA,SA4FbM,SA5Fa,GA4FD,OAAOZ,OAAP,EAAwBC,IAAxB,KAA8D;AACtE,UAAI;AACA,cAAMO,OAAO,GAAG,MAAM,KAAKC,UAAL,CAAgB,KAAhB,CAAtB;AACAD,QAAAA,OAAO,CAACE,IAAR,GAAeP,IAAI,CAACC,SAAL,CAAeH,IAAf,CAAf;AACA,eAAO,KAAKU,kBAAL,CAAwBf,MAAM,CAACI,OAAD,CAA9B,EAAyCQ,OAAzC,CAAP;AACH,OAJD,CAKA,OAAOF,GAAP,EAAY;AACR,cAAMA,GAAN;AACH;AACJ,KArGY;;AAAA,SAuGbb,GAvGa,GAuGP,MAAOO,OAAP,IAAgD;AAClD,UAAI;AACA,cAAMQ,OAAO,GAAG,MAAM,KAAKC,UAAL,CAAgB,KAAhB,CAAtB;AACA,eAAO,MAAM,KAAKE,kBAAL,CAAwBf,MAAM,CAACI,OAAD,CAA9B,EAAyCQ,OAAzC,CAAb;AACH,OAHD,CAIA,OAAOF,GAAP,EAAY;AACR,cAAMA,GAAN;AACH;AACJ,KA/GY;;AAAA,SAiHbO,MAjHa,GAiHJ,OAAOb,OAAP,EAAwBC,IAAxB,KAA+D;AACpE,UAAI;AACA,cAAMO,OAAO,GAAG,MAAM,KAAKC,UAAL,CAAgB,QAAhB,CAAtB;AACAD,QAAAA,OAAO,CAACE,IAAR,GAAeP,IAAI,CAACC,SAAL,CAAeH,IAAf,CAAf;AACA,eAAO,KAAKU,kBAAL,CAAwBf,MAAM,CAACI,OAAD,CAA9B,EAAyCQ,OAAzC,CAAP;AACH,OAJD,CAKA,OAAOF,GAAP,EAAY;AACR,cAAMA,GAAN;AACH;AACJ,KA1HY;;AAAA,SA4HbQ,MA5Ha,GA4HJ,MAAOd,OAAP,IAAyC;AAC9C,UAAI;AACA,cAAMQ,OAAO,GAAG,MAAM,KAAKC,UAAL,CAAgB,KAAhB,CAAtB;AACA,eAAO,KAAKE,kBAAL,CAAwBX,OAAxB,EAAiCQ,OAAjC,CAAP;AACH,OAHD,CAIA,OAAOF,GAAP,EAAY;AACR,cAAMA,GAAN;AACH;AACJ,KApIY;AAAA;;AAEG,QAAVG,UAAU,CAACM,IAAD,EAAeR,OAAf,EAA+C;AAC3D,UAAMS,eAAe,GAAGvB,GAAG,CAACc,OAAD,EAAU,iBAAV,EAA6B,EAA7B,CAA3B;AACA,UAAMC,OAAO,GAAG;AACZS,MAAAA,MAAM,EAAEF,IADI;AAEZG,MAAAA,OAAO,EAAE;AACL,wBAAgB,kBADX;AAELC,QAAAA,aAAa,EAAG,gDAFX;AAGL,oBAAYtB,MAAM,CAACuB,EAAP,CAAUC,KAAV,EAHP;AAIL,WAAGL;AAJE;AAFG,KAAhB,CAF2D,CAY3D;AACA;;AACA,UAAMM,KAAK,GAAG3B,cAAc,CAAC4B,OAAf,CAAuB,UAAvB,CAAd;;AACA,QAAIP,eAAe,CAAC,cAAD,CAAf,KAAoC,qBAAxC,EAA+D;AAC3D,aAAOR,OAAO,CAACU,OAAR,CAAgB,cAAhB,CAAP;AACH;;AACD,QAAII,KAAJ,EAAW;AACPd,MAAAA,OAAO,CAACU,OAAR,GAAkB,EACd,GAAGV,OAAO,CAACU,OADG;AAEdC,QAAAA,aAAa,EAAEG,KAFD;AAGd,oBAAYzB,MAAM,CAACuB,EAAP,CAAUC,KAAV,EAHE,CAId;;AAJc,OAAlB;AAMH;;AACD,WAAOb,OAAP;AACH;;AAEuB,QAAlBG,kBAAkB,CAACa,GAAD,EAAchB,OAAd,EAA4B;AAChD,QAAI;AACA,YAAMiB,QAAa,GAAG,MAAMC,KAAK,CAACF,GAAD,EAAMhB,OAAN,CAAjC;;AACA,UAAI,CAACiB,QAAQ,CAACE,EAAd,EAAkB;AACd,YAAIF,QAAQ,CAACG,MAAT,KAAoB,GAAxB,EAA6B;AACzB,cAAIjC,cAAc,CAAC4B,OAAf,CAAuB,UAAvB,CAAJ,EAAwC;AACpC5B,YAAAA,cAAc,CAACkC,QAAf,GADoC,CAEpC;;AACA,kBAAMC,IAAI,GAAG,MAAML,QAAQ,CAACM,IAAT,EAAnB;AACA,kBAAMC,IAAI,GAAG7B,IAAI,CAAC8B,KAAL,CAAWH,IAAX,CAAb;AACApC,YAAAA,YAAY,CAAC,IAAD,EAAOsC,IAAI,CAACE,OAAL,IAAgB,yBAAvB,CAAZ;AACAC,YAAAA,UAAU,CAAC,MAAM;AACbC,cAAAA,MAAM,CAACC,QAAP,CAAgBC,QAAhB,GAA2B,QAA3B;AACH,aAFS,EAEP,IAFO,CAAV;AAGA;AACH;AACJ,SAZD,MAaK,IAAIb,QAAQ,CAACG,MAAT,KAAoB,GAApB,IAA2BH,QAAQ,CAACG,MAAT,KAAoB,GAAnD,EAAwD;AACzDW,UAAAA,OAAO,CAACC,GAAR,CAAY,6BAAZ,EAA2Cf,QAA3C;AACH;;AACD,cAAMnB,GAAG,GAAG,MAAMmB,QAAQ,CAACgB,IAAT,EAAlB;AACAF,QAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ,EAAyBlC,GAAzB;AACA,cAAMA,GAAN;AACH,OApBD,MAqBK;AACD,cAAMoC,GAAG,GAAG,MAAMjB,QAAQ,CAACM,IAAT,EAAlB;;AACA,YAAI;AACA,iBAAO5B,IAAI,CAAC8B,KAAL,CAAWS,GAAX,CAAP;AACH,SAFD,CAGA,MAAM;AACF,iBAAOA,GAAP;AACH;AACJ;AACJ,KAhCD,CAiCA,OAAOC,KAAP,EAAc;AACVJ,MAAAA,OAAO,CAACC,GAAR,CAAY,OAAZ,EAAqBG,KAArB;AACA,aAAOA,KAAP;AACH;AACJ;;AArEY;;AAuIjB,eAAe,IAAI7C,UAAJ,EAAf","sourcesContent":["import { get } from 'lodash';\nimport { setShowToast } from '../redux/common/actions';\nimport storageService from '../utils/storageService';\nimport { urlFor } from './Urls';\nimport * as moment from 'moment';\nimport 'moment-timezone';\n\nexport interface FetchResponse {\n    status?: number | boolean,\n    status_code?: number\n    message: string,\n    result: any,\n    data: any\n}\n\nclass NetworkOps {\n\n    async getRequest(type: string, options?: object): Promise<any> {\n        const headerOverrides = get(options, 'headerOverrides', {});\n        const request = {\n            method: type,\n            headers: {\n                'Content-Type': 'application/json',\n                Authorization: `Basic dGlja3RfYXBwOnRpY2t0X2FwcF8xMjNzYWRlZnNz`,\n                'timezone': moment.tz.guess(),\n                ...headerOverrides\n            },\n        };\n\n        //if giving multipart/form-data in Content-Type: giving boundary error\n        //if also adding boundary: loader continues from server end \n        const token = storageService.getItem('jwtToken');\n        if (headerOverrides['Content-Type'] === 'multipart/form-data') {\n            delete request.headers['Content-Type'];\n        }\n        if (token) {\n            request.headers = {\n                ...request.headers,\n                Authorization: token,\n                'timezone': moment.tz.guess(),\n                // Authorization: `Bearer ${token}`,\n            }\n        }\n        return request;\n    }\n\n    async wrapperWithOptions(url: string, request: any) {\n        try {\n            const response: any = await fetch(url, request);\n            if (!response.ok) {\n                if (response.status === 401) {\n                    if (storageService.getItem('jwtToken')) {\n                        storageService.clearAll();\n                        // alert('Token Expired');\n                        const res1 = await response.text();\n                        const res2 = JSON.parse(res1);\n                        setShowToast(true, res2.message || 'You\\'ve been logged out');\n                        setTimeout(() => {\n                            window.location.pathname = '/login';\n                        }, 1000);\n                        return;\n                    }\n                }\n                else if (response.status === 500 || response.status === 400) {\n                    console.log('Got 401, now calling logout', response);\n                }\n                const err = await response.json();\n                console.log('Error -> ', err)\n                throw err;\n            }\n            else {\n                const res = await response.text();\n                try {\n                    return JSON.parse(res);\n                }\n                catch {\n                    return res;\n                }\n            }\n        }\n        catch (error) {\n            console.log('Error', error);\n            return error;\n        }\n    }\n\n    postToJson = async (service: string, data: any): Promise<FetchResponse> => {\n        try {\n            const JSONData = JSON.stringify(data);\n            return this.postRaw(service, JSONData)\n        }\n        catch (err) {\n            throw err;\n        }\n    }\n\n    postRaw = async (service: string, data: any, options?: any): Promise<FetchResponse> => {\n        try {\n            const request = await this.getRequest('POST', options);\n            request.body = data;\n            return this.wrapperWithOptions(urlFor(service), request)\n        }\n        catch (err) {\n            throw err;\n        }\n    }\n\n    putToJson = async (service: string, data: any): Promise<FetchResponse> => {\n        try {\n            const request = await this.getRequest('PUT');\n            request.body = JSON.stringify(data);\n            return this.wrapperWithOptions(urlFor(service), request)\n        }\n        catch (err) {\n            throw err;\n        }\n    }\n\n    get = async (service: any): Promise<FetchResponse> => {\n        try {\n            const request = await this.getRequest('GET');\n            return await this.wrapperWithOptions(urlFor(service), request);\n        }\n        catch (err) {\n            throw err;\n        }\n    }\n\n    delete = async (service: string, data?: any): Promise<FetchResponse> => {\n        try {\n            const request = await this.getRequest('DELETE');\n            request.body = JSON.stringify(data);\n            return this.wrapperWithOptions(urlFor(service), request)\n        }\n        catch (err) {\n            throw err;\n        }\n    }\n\n    getRaw = async (service: string): Promise<any> => {\n        try {\n            const request = await this.getRequest('GET');\n            return this.wrapperWithOptions(service, request)\n        }\n        catch (err) {\n            throw err;\n        }\n    }\n}\n\nexport default new NetworkOps();"]},"metadata":{},"sourceType":"module"}