{"ast":null,"code":"import firebase from \"firebase/app\";\nimport \"firebase/messaging\";\nimport \"firebase/auth\";\nimport \"firebase/database\";\nimport storageService from \"../utils/storageService\";\nimport Constants from \"../utils/constants\";\nimport moment from \"moment\";\n\nif (!firebase.apps.length) {\n  firebase.initializeApp(Constants.qaStgFirebaseConfig);\n}\n\nconst checkIfSupport = () => {\n  if (firebase.messaging.isSupported()) {\n    return firebase.messaging();\n  }\n\n  return false;\n};\n\nexport const auth = firebase.auth();\nexport const messaging = checkIfSupport(); //firebase.messaging();\n\nexport const db = firebase.database();\nconst CHAT_TYPE = \"single\";\nconst FIREBASE_COLLECTION = {\n  ROOM_INFO: \"room_info\",\n  JOBS: \"jobs\",\n  INBOX: \"inbox\",\n  MESSAGES: \"messages\",\n  LAST_MESSAGES: \"lastMessage\",\n  USERS: \"users\"\n};\nlet loggedInuserId = \"\";\nlet msgListnerObj; // let totalPendingCounter = 0;\n\nlet inboxListner;\n\nconst getRegisterToken = () => {\n  return new Promise((resolve, reject) => {\n    messaging.getToken({\n      vapidKey: Constants.FirebasePushServiceKey\n    }).then(currentToken => {\n      if (currentToken) {\n        console.log(\"firebase token fetched successsfully\", currentToken);\n        resolve({\n          success: true,\n          deviceToken: currentToken\n        });\n      } else {\n        console.log(\"No registration token available.\");\n        setTokenSentToServer(false);\n        resolve({\n          success: false\n        });\n      }\n    }).catch(err => {\n      console.log(\"An error occurred while retrieving  from firebase. \", err);\n      setTokenSentToServer(false);\n      reject({\n        success: false\n      });\n    });\n  });\n};\n\nconst setTokenSentToServer = sent => {\n  storageService.setItem(\"sentToServer\", sent ? \"1\" : \"0\");\n  storageService.setItem(\"fcmToken\", \"\");\n};\n\nconst isTokenSentToServer = () => {\n  return storageService.getItem(\"sentToServer\") === \"1\";\n};\n\nexport const requestPermission = () => {\n  if (checkIfSupport()) {\n    return new Promise((resolve, reject) => {\n      Notification.requestPermission().then(permission => {\n        const data = getRegisterToken();\n        resolve(data);\n      }) // if (permission === 'granted' && isTokenSentToServer()) {\n      //     const data = getRegisterToken();\n      //     console.log('Token Already sent');\n      //     resolve(data);\n      // }\n      .catch(err => {\n        console.log(\"Unable to get permission to show notification browser : \", err);\n        reject({\n          success: false\n        });\n      });\n    });\n  }\n};\nexport const deleteToken = () => {\n  if (checkIfSupport()) {\n    messaging.deleteToken().then(() => {\n      console.log(\"firebase Token deleted.\");\n    }).catch(err => {\n      console.log(\"Unable to delete firebase token. \", err);\n    });\n  }\n};\nexport const signOut = () => {\n  auth.signOut().then(() => {\n    console.log(\"Firebase signout successful.\");\n  }).catch(err => {\n    console.log(\"Firebase sign out error.\", err);\n  });\n};\nexport const firebaseSignUpWithEmailPassword = async ({\n  email,\n  password,\n  id,\n  fullName,\n  user_type\n}) => {\n  try {\n    let ref = await auth.createUserWithEmailAndPassword(email, password);\n\n    if (ref) {\n      await ref.user.updateProfile({\n        displayName: fullName // photoURL: '',\n        // roleId: user_type,\n\n      });\n      await db.ref(`${FIREBASE_COLLECTION.USERS}/${id}`).set({\n        email: email,\n        image: \"\",\n        name: fullName,\n        // uid: ref.user[\"$\"][\"W\"],\n        userId: id,\n        onlineStatus: true,\n        userType: user_type\n      });\n      console.log(\"firebase authentication success\");\n    }\n  } catch (err) {\n    console.log(\"firebase authentication failure: \", {\n      err\n    });\n  }\n};\nexport const firebaseLogInWithEmailPassword = async (authData, loginRes, isSignup) => {\n  console.log(\"authData: \", authData);\n\n  try {\n    let response = await auth.signInWithEmailAndPassword(authData.email, authData.password);\n\n    if (response) {\n      console.log(\"firebase auth login success: \");\n      if (isSignup) return;\n      await db.ref(`${FIREBASE_COLLECTION.USERS}/${loginRes === null || loginRes === void 0 ? void 0 : loginRes._id}`).set({\n        email: loginRes === null || loginRes === void 0 ? void 0 : loginRes.email,\n        image: loginRes === null || loginRes === void 0 ? void 0 : loginRes.user_image,\n        name: loginRes === null || loginRes === void 0 ? void 0 : loginRes.userName,\n        userId: loginRes === null || loginRes === void 0 ? void 0 : loginRes._id,\n        onlineStatus: true,\n        userType: loginRes === null || loginRes === void 0 ? void 0 : loginRes.user_type\n      });\n    }\n  } catch (err) {\n    console.log(\"firebase auth login failure: \");\n  }\n}; ////////////////////////  firebase chat\n\nexport const loginAnonymously = async () => {\n  let userInfo = storageService.getItem(\"userInfo\");\n\n  try {\n    let response = await auth.signInAnonymously();\n\n    if (response) {\n      console.log(\"firebase anonymous auth login success: \");\n      await db.ref(`${FIREBASE_COLLECTION.USERS}/${userInfo === null || userInfo === void 0 ? void 0 : userInfo._id}`).update({\n        email: userInfo === null || userInfo === void 0 ? void 0 : userInfo.email,\n        image: userInfo === null || userInfo === void 0 ? void 0 : userInfo.user_image,\n        name: userInfo === null || userInfo === void 0 ? void 0 : userInfo.userName,\n        userId: userInfo === null || userInfo === void 0 ? void 0 : userInfo._id,\n        onlineStatus: true,\n        userType: userInfo === null || userInfo === void 0 ? void 0 : userInfo.user_type,\n        deviceType: 1\n      });\n    }\n  } catch (error) {\n    console.log(\"firebase anonymous auth login failure: \");\n    var errorCode = error.code;\n\n    if (errorCode === \"auth/operation-not-allowed\") {\n      alert(\"You must enable Anonymous auth in the Firebase Console.\");\n    } else {\n      console.error(error);\n    }\n  }\n};\nexport const getLoggedInuserId = () => {\n  var _storageService$getIt;\n\n  return (_storageService$getIt = storageService.getItem(\"userInfo\")) === null || _storageService$getIt === void 0 ? void 0 : _storageService$getIt._id;\n};\nexport const updateChatUserDetails = async (updateType, value) => {\n  let loggedInuserId = getLoggedInuserId();\n\n  try {\n    await db.ref(`${FIREBASE_COLLECTION.USERS}/${loggedInuserId}`).update({ ...(updateType === \"userImage\" && {\n        image: value\n      }),\n      ...(updateType === \"userName\" && {\n        name: value\n      }),\n      ...(updateType === \"deviceToken\" && {\n        deviceToken: value\n      }),\n      ...(updateType === \"isNotification\" && {\n        isNotification: value\n      })\n    });\n    console.log(`firebase ${updateType} update success`);\n  } catch (err) {\n    console.log(`firebase ${updateType} update failure: `, {\n      err\n    });\n  }\n};\nexport const createRoom = async (jobId, tradieId, builderId, jobName) => {\n  let loggedInuserId = getLoggedInuserId();\n  const roomID = `${jobId}_${tradieId}_${builderId}`;\n\n  if (await checkRoomExist(roomID)) {\n    return;\n  }\n\n  let roomInfoObj = {\n    id: roomID,\n    chatRoomType: CHAT_TYPE,\n    chatLastUpdate: firebase.database.ServerValue.TIMESTAMP\n  };\n  let chatLastUpdates = {};\n  chatLastUpdates[tradieId] = tradieId === loggedInuserId ? firebase.database.ServerValue.TIMESTAMP : 0;\n  chatLastUpdates[loggedInuserId] = firebase.database.ServerValue.TIMESTAMP;\n  let chatRoomMembers = {};\n  chatRoomMembers[tradieId] = {\n    memberDelete: firebase.database.ServerValue.TIMESTAMP,\n    memberJoin: firebase.database.ServerValue.TIMESTAMP,\n    memberLeave: 0\n  };\n  chatRoomMembers[builderId] = {\n    memberDelete: firebase.database.ServerValue.TIMESTAMP,\n    memberJoin: firebase.database.ServerValue.TIMESTAMP,\n    memberLeave: 0\n  };\n  roomInfoObj.chatRoomMembers = chatRoomMembers;\n  roomInfoObj.chatLastUpdates = chatLastUpdates;\n  await db.ref(`${FIREBASE_COLLECTION.ROOM_INFO}/${roomID}/`).set(roomInfoObj); // debugger;\n  // await createItem(itemInfo);\n  //loggedin user inbox\n\n  await createInbox(tradieId, roomID, jobId, builderId, jobName); // opposite user inbox\n\n  await createInbox(builderId, roomID, jobId, tradieId, jobName);\n  return roomInfoObj;\n};\nexport const checkRoomExist = async roomID => {\n  let room = await db.ref(`${FIREBASE_COLLECTION.ROOM_INFO}/${roomID}/`).once(\"value\");\n  return room.exists();\n};\nexport const createJob = async jobInfo => {\n  await db.ref(`${FIREBASE_COLLECTION.JOBS}/${jobInfo.jobId}/`).set(jobInfo);\n};\nexport const createInbox = async (userid, roomId, jobId, oppuserid, jobName) => {\n  const inboxKey = `${oppuserid}_${jobId}`;\n  await db.ref(`${FIREBASE_COLLECTION.INBOX}/${userid}/${inboxKey}`).set({\n    jobId: jobId,\n    jobName: jobName,\n    roomId: roomId,\n    unreadMessages: 0\n  });\n};\nexport const getFirebaseInboxData = async listner => {\n  // debugger;\n  let userId = getLoggedInuserId();\n\n  if (!userId) {\n    listner([]);\n    return;\n  }\n\n  let dbRef = `${FIREBASE_COLLECTION.INBOX}/${userId}`;\n  console.log(\"getFirebaseIndexData\", dbRef);\n\n  if (inboxListner) {\n    db.ref(dbRef).off();\n    db.ref(dbRef).off(\"value\", msgListnerObj);\n  }\n\n  inboxListner = db.ref(dbRef).on(\"value\", async snapshot => {\n    let indexlist = [];\n    snapshot.forEach(snap => {\n      indexlist.push(snap.val());\n    });\n    let items = [];\n    let users = [];\n\n    for (let i = 0; i < indexlist.length; i++) {\n      // let itemIndex = items.findIndex((item) => item.jobId === indexlist[i].jobId);\n      // if (itemIndex == -1) {\n      //     let room = await db.ref(`${FIREBASE_COLLECTION.JOBS}/${indexlist[i].jobId}`).once('value');\n      //     if (room.exists()) {\n      //         let lastMsg = await db.ref(`${FIREBASE_COLLECTION.LAST_MESSAGES}/${indexlist[i].roomId}/chatLastMessage`).once('value');\n      //         indexlist[i].item = room.val();\n      //         if (lastMsg.exists())\n      //             indexlist[i].lastMsg = lastMsg.val();\n      //         items.push(room.val());\n      //     }\n      // } else {\n      //     indexlist[i].item = items[itemIndex];\n      // }\n      let lastMsg = await db.ref(`${FIREBASE_COLLECTION.LAST_MESSAGES}/${indexlist[i].roomId}/chatLastMessage`).once(\"value\");\n\n      if (lastMsg.exists()) {\n        indexlist[i].lastMsg = lastMsg.val();\n      }\n\n      let oppUserId = \"\";\n\n      if (storageService.getItem(\"userType\") === 1) {\n        oppUserId = indexlist[i].roomId.split(\"_\")[2];\n      } else {\n        oppUserId = indexlist[i].roomId.split(\"_\")[1];\n      }\n\n      let userIndex = users.findIndex(item => item.userId === oppUserId);\n\n      if (userIndex == -1) {\n        let oppUserInfo = await db.ref(`${FIREBASE_COLLECTION.USERS}/${oppUserId}`).once(\"value\");\n\n        if (oppUserInfo.exists()) {\n          indexlist[i].oppUserInfo = oppUserInfo.val();\n          users.push(oppUserInfo.val());\n        }\n      } else {\n        indexlist[i].oppUserInfo = users[userIndex];\n      }\n    }\n\n    setPendingCounter(indexlist);\n    await listner(indexlist);\n  });\n};\nexport const getFirebaseInboxDataForUnreadMsgCount = async listner => {\n  // debugger;\n  let userId = getLoggedInuserId();\n\n  if (!userId) {\n    listner([]);\n    return;\n  }\n\n  let dbRef = `${FIREBASE_COLLECTION.INBOX}/${userId}`;\n  console.log(\"getFirebaseIndexData\", dbRef);\n  inboxListner = db.ref(dbRef).on(\"value\", async snapshot => {\n    let indexlist = [];\n    snapshot.forEach(snap => {\n      indexlist.push(snap.val());\n    });\n    let items = [];\n    let users = [];\n\n    for (let i = 0; i < indexlist.length; i++) {\n      // let itemIndex = items.findIndex((item) => item.jobId === indexlist[i].jobId);\n      // if (itemIndex == -1) {\n      //     let room = await db.ref(`${FIREBASE_COLLECTION.JOBS}/${indexlist[i].jobId}`).once('value');\n      //     if (room.exists()) {\n      //         let lastMsg = await db.ref(`${FIREBASE_COLLECTION.LAST_MESSAGES}/${indexlist[i].roomId}/chatLastMessage`).once('value');\n      //         indexlist[i].item = room.val();\n      //         if (lastMsg.exists())\n      //             indexlist[i].lastMsg = lastMsg.val();\n      //         items.push(room.val());\n      //     }\n      // } else {\n      //     indexlist[i].item = items[itemIndex];\n      // }\n      let lastMsg = await db.ref(`${FIREBASE_COLLECTION.LAST_MESSAGES}/${indexlist[i].roomId}/chatLastMessage`).once(\"value\");\n\n      if (lastMsg.exists()) {\n        indexlist[i].lastMsg = lastMsg.val();\n      }\n\n      let oppUserId = \"\";\n\n      if (storageService.getItem(\"userType\") === 1) {\n        oppUserId = indexlist[i].roomId.split(\"_\")[2];\n      } else {\n        oppUserId = indexlist[i].roomId.split(\"_\")[1];\n      }\n\n      let userIndex = users.findIndex(item => item.userId === oppUserId);\n\n      if (userIndex == -1) {\n        let oppUserInfo = await db.ref(`${FIREBASE_COLLECTION.USERS}/${oppUserId}`).once(\"value\");\n\n        if (oppUserInfo.exists()) {\n          indexlist[i].oppUserInfo = oppUserInfo.val();\n          users.push(oppUserInfo.val());\n        }\n      } else {\n        indexlist[i].oppUserInfo = users[userIndex];\n      }\n    }\n\n    setPendingCounter(indexlist);\n    await listner(indexlist);\n  });\n};\nexport const setPendingCounter = indexlist => {\n  let count = 0;\n  let unreadMsg = indexlist.filter(d => d.unreadMessages > 0);\n  unreadMsg.length === 0 ? count = 0 : count = unreadMsg.length; // store.dispatch({\n  //     type: INBOX_COUNTER_SET,\n  //     payLoad: count\n  // });\n}; // export const getFirebaseItemsData = async () => {\n//     let itemlist = [];\n//     db.ref(`${FIREBASE_COLLECTION.JOBS}`).on(\"value\", (snapshot) => {\n//         snapshot.forEach((snap) => {\n//             itemlist.push(snap.val());\n//         });\n//     });\n//     return itemlist;\n// }\n// export const getFirebaseRoomInfoData = async () => {\n//     let roomlist = [];\n//     db.ref(`${FIREBASE_COLLECTION.ROOM_INFO}`).on(\"value\", (snapshot) => {\n//         snapshot.forEach((snap) => {\n//             roomlist.push(snap.val());\n//         });\n//     });\n//     return roomlist\n// }\n\nexport const getMessagesOfRoom = async (roomId, listner) => {\n  //getPreviousMessages check KT file\n  //.limitToLast(10)\n  // if (msgListnerObj) {\n  //     await db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`).off('value', msgListnerObj);\n  // }\n  msgListnerObj = db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`).orderByChild(\"messageTimestamp\").limitToLast(500).on(\"value\", snapshot => {\n    let itemlist = [];\n    snapshot.forEach(snap => {\n      itemlist.push(snap.val());\n    });\n    listner(itemlist);\n  });\n};\nexport const stopListeningOfRoom = async roomId => {\n  if (msgListnerObj) {\n    db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`).off(\"value\", msgListnerObj);\n    db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`).off();\n  }\n\n  console.log(\"Stop listening Of Room\");\n};\nexport const sendTextMessage = async (roomId, message) => {\n  let senderId = getLoggedInuserId();\n  let roomids = roomId.split(\"_\");\n  let jobId = \"\";\n  let receiverId = \"\";\n\n  if (roomids.length == 3) {\n    if (roomids[1] == senderId) {\n      receiverId = roomids[2];\n    } else {\n      receiverId = roomids[1];\n    }\n\n    jobId = roomids[0];\n  }\n\n  let dbRef = db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`);\n  const newMsgRef = dbRef.push(); // Get the unique key generated by push()\n\n  const messageID = newMsgRef.key;\n  let msgData = {\n    isBlock: false,\n    isDeleted: false,\n    mediaDuration: \"\",\n    mediaUrl: \"\",\n    messageCaption: \"\",\n    messageId: messageID,\n    messageRoomId: roomId,\n    messageStatus: \"send\",\n    messageText: message,\n    messageTimestamp: firebase.database.ServerValue.TIMESTAMP,\n    messageType: \"text\",\n    progress: 0,\n    receiverId: receiverId,\n    senderId: senderId,\n    thumbnail: \"\"\n  };\n  await db.ref(`${FIREBASE_COLLECTION.LAST_MESSAGES}/${roomId}/chatLastMessage`).set(msgData);\n  await db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}/${messageID}`).set(msgData);\n  msgData.messageTimestamp = moment().toDate().getTime(); //TODO Implement Update Message Counter\n  //https://stackoverflow.com/questions/42276881/increment-firebase-value-from-javascript-subject-to-constraint\n\n  let inboxId = `${senderId}_${jobId}`;\n  await db.ref(`${FIREBASE_COLLECTION.INBOX}/${receiverId}/${inboxId}`).child(\"unreadMessages\").set(firebase.database.ServerValue.increment(1));\n  return msgData;\n};\nexport const sendImageVideoMessage = async (roomId, url, type) => {\n  let senderId = getLoggedInuserId();\n  let roomids = roomId.split(\"_\");\n  let jobId = \"\";\n  let receiverId = \"\";\n\n  if (roomids.length == 3) {\n    if (roomids[1] == senderId) {\n      receiverId = roomids[2];\n    } else {\n      receiverId = roomids[1];\n    }\n\n    jobId = roomids[0];\n  }\n\n  let dbRef = db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`);\n  const newMsgRef = dbRef.push(); // Get the unique key generated by push()\n\n  const messageID = newMsgRef.key;\n  let msgData = {\n    isBlock: false,\n    isDeleted: false,\n    mediaDuration: \"\",\n    mediaUrl: url,\n    messageCaption: \"\",\n    messageId: messageID,\n    messageRoomId: roomId,\n    messageStatus: \"send\",\n    messageText: \"\",\n    messageTimestamp: firebase.database.ServerValue.TIMESTAMP,\n    messageType: type === \"image\" ? \"image\" : \"video\",\n    progress: 0,\n    receiverId: receiverId,\n    senderId: senderId,\n    thumbnail: url\n  };\n  await db.ref(`${FIREBASE_COLLECTION.LAST_MESSAGES}/${roomId}/chatLastMessage`).set(msgData);\n  await db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}/${messageID}`).set(msgData);\n  msgData.messageTimestamp = moment().toDate().getTime(); //Implement Update Message Counter\n  //https://stackoverflow.com/questions/42276881/increment-firebase-value-from-javascript-subject-to-constraint\n\n  let inboxId = `${senderId}_${jobId}`;\n  await db.ref(`${FIREBASE_COLLECTION.INBOX}/${receiverId}/${inboxId}`).child(\"unreadMessages\").set(firebase.database.ServerValue.increment(1));\n  return msgData;\n};\nexport const resetUnreadCounter = async roomId => {\n  let senderId = getLoggedInuserId();\n  let roomids = roomId.split(\"_\");\n  let jobId = \"\";\n  let receiverId = \"\";\n\n  if (roomids.length === 3) {\n    if (roomids[1] == senderId) {\n      receiverId = roomids[2];\n    } else {\n      receiverId = roomids[1];\n    }\n\n    jobId = roomids[0];\n  }\n\n  let inboxId = `${receiverId}_${jobId}`;\n  await db.ref(`${FIREBASE_COLLECTION.INBOX}/${senderId}/${inboxId}`).child(\"unreadMessages\").set(0);\n};\nexport default firebase;","map":{"version":3,"sources":["/home/appinventiv/Documents/Project/tickt/web/src/services/firebase.js"],"names":["firebase","storageService","Constants","moment","apps","length","initializeApp","qaStgFirebaseConfig","checkIfSupport","messaging","isSupported","auth","db","database","CHAT_TYPE","FIREBASE_COLLECTION","ROOM_INFO","JOBS","INBOX","MESSAGES","LAST_MESSAGES","USERS","loggedInuserId","msgListnerObj","inboxListner","getRegisterToken","Promise","resolve","reject","getToken","vapidKey","FirebasePushServiceKey","then","currentToken","console","log","success","deviceToken","setTokenSentToServer","catch","err","sent","setItem","isTokenSentToServer","getItem","requestPermission","Notification","permission","data","deleteToken","signOut","firebaseSignUpWithEmailPassword","email","password","id","fullName","user_type","ref","createUserWithEmailAndPassword","user","updateProfile","displayName","set","image","name","userId","onlineStatus","userType","firebaseLogInWithEmailPassword","authData","loginRes","isSignup","response","signInWithEmailAndPassword","_id","user_image","userName","loginAnonymously","userInfo","signInAnonymously","update","deviceType","error","errorCode","code","alert","getLoggedInuserId","updateChatUserDetails","updateType","value","isNotification","createRoom","jobId","tradieId","builderId","jobName","roomID","checkRoomExist","roomInfoObj","chatRoomType","chatLastUpdate","ServerValue","TIMESTAMP","chatLastUpdates","chatRoomMembers","memberDelete","memberJoin","memberLeave","createInbox","room","once","exists","createJob","jobInfo","userid","roomId","oppuserid","inboxKey","unreadMessages","getFirebaseInboxData","listner","dbRef","off","on","snapshot","indexlist","forEach","snap","push","val","items","users","i","lastMsg","oppUserId","split","userIndex","findIndex","item","oppUserInfo","setPendingCounter","getFirebaseInboxDataForUnreadMsgCount","count","unreadMsg","filter","d","getMessagesOfRoom","orderByChild","limitToLast","itemlist","stopListeningOfRoom","sendTextMessage","message","senderId","roomids","receiverId","newMsgRef","messageID","key","msgData","isBlock","isDeleted","mediaDuration","mediaUrl","messageCaption","messageId","messageRoomId","messageStatus","messageText","messageTimestamp","messageType","progress","thumbnail","toDate","getTime","inboxId","child","increment","sendImageVideoMessage","url","type","resetUnreadCounter"],"mappings":"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","sourcesContent":["import firebase from \"firebase/app\";\nimport \"firebase/messaging\";\nimport \"firebase/auth\";\nimport \"firebase/database\";\nimport storageService from \"../utils/storageService\";\nimport Constants from \"../utils/constants\";\nimport moment from \"moment\";\n\nif (!firebase.apps.length) {\n  firebase.initializeApp(Constants.qaStgFirebaseConfig);\n}\n\nconst checkIfSupport = () => {\n  if (firebase.messaging.isSupported()) {\n    return firebase.messaging();\n  }\n  return false;\n};\n\nexport const auth = firebase.auth();\nexport const messaging = checkIfSupport(); //firebase.messaging();\nexport const db = firebase.database();\n\nconst CHAT_TYPE = \"single\";\nconst FIREBASE_COLLECTION = {\n  ROOM_INFO: \"room_info\",\n  JOBS: \"jobs\",\n  INBOX: \"inbox\",\n  MESSAGES: \"messages\",\n  LAST_MESSAGES: \"lastMessage\",\n  USERS: \"users\",\n};\nlet loggedInuserId = \"\";\nlet msgListnerObj;\n// let totalPendingCounter = 0;\nlet inboxListner;\n\nconst getRegisterToken = () => {\n  return new Promise((resolve, reject) => {\n    messaging\n      .getToken({\n        vapidKey: Constants.FirebasePushServiceKey,\n      })\n      .then((currentToken) => {\n        if (currentToken) {\n          console.log(\"firebase token fetched successsfully\", currentToken);\n          resolve({ success: true, deviceToken: currentToken });\n        } else {\n          console.log(\"No registration token available.\");\n          setTokenSentToServer(false);\n          resolve({ success: false });\n        }\n      })\n      .catch((err) => {\n        console.log(\"An error occurred while retrieving  from firebase. \", err);\n        setTokenSentToServer(false);\n        reject({ success: false });\n      });\n  });\n};\n\nconst setTokenSentToServer = (sent) => {\n  storageService.setItem(\"sentToServer\", sent ? \"1\" : \"0\");\n  storageService.setItem(\"fcmToken\", \"\");\n};\n\nconst isTokenSentToServer = () => {\n  return storageService.getItem(\"sentToServer\") === \"1\";\n};\n\nexport const requestPermission = () => {\n  if (checkIfSupport()) {\n    return new Promise((resolve, reject) => {\n      Notification.requestPermission()\n        .then((permission) => {\n          const data = getRegisterToken();\n          resolve(data);\n        })\n        // if (permission === 'granted' && isTokenSentToServer()) {\n        //     const data = getRegisterToken();\n        //     console.log('Token Already sent');\n        //     resolve(data);\n        // }\n        .catch((err) => {\n          console.log(\n            \"Unable to get permission to show notification browser : \",\n            err\n          );\n          reject({ success: false });\n        });\n    });\n  }\n};\n\nexport const deleteToken = () => {\n  if (checkIfSupport()) {\n    messaging\n      .deleteToken()\n      .then(() => {\n        console.log(\"firebase Token deleted.\");\n      })\n      .catch((err) => {\n        console.log(\"Unable to delete firebase token. \", err);\n      });\n  }\n};\n\nexport const signOut = () => {\n  auth\n    .signOut()\n    .then(() => {\n      console.log(\"Firebase signout successful.\");\n    })\n    .catch((err) => {\n      console.log(\"Firebase sign out error.\", err);\n    });\n};\n\nexport const firebaseSignUpWithEmailPassword = async ({\n  email,\n  password,\n  id,\n  fullName,\n  user_type,\n}) => {\n  try {\n    let ref = await auth.createUserWithEmailAndPassword(email, password);\n    if (ref) {\n      await ref.user.updateProfile({\n        displayName: fullName,\n        // photoURL: '',\n        // roleId: user_type,\n      });\n\n      await db.ref(`${FIREBASE_COLLECTION.USERS}/${id}`).set({\n        email: email,\n        image: \"\",\n        name: fullName,\n        // uid: ref.user[\"$\"][\"W\"],\n        userId: id,\n        onlineStatus: true,\n        userType: user_type,\n      });\n      console.log(\"firebase authentication success\");\n    }\n  } catch (err) {\n    console.log(\"firebase authentication failure: \", { err });\n  }\n};\n\nexport const firebaseLogInWithEmailPassword = async (\n  authData,\n  loginRes,\n  isSignup\n) => {\n  console.log(\"authData: \", authData);\n  try {\n    let response = await auth.signInWithEmailAndPassword(\n      authData.email,\n      authData.password\n    );\n    if (response) {\n      console.log(\"firebase auth login success: \");\n      if (isSignup) return;\n      await db.ref(`${FIREBASE_COLLECTION.USERS}/${loginRes?._id}`).set({\n        email: loginRes?.email,\n        image: loginRes?.user_image,\n        name: loginRes?.userName,\n        userId: loginRes?._id,\n        onlineStatus: true,\n        userType: loginRes?.user_type,\n      });\n    }\n  } catch (err) {\n    console.log(\"firebase auth login failure: \");\n  }\n};\n\n////////////////////////  firebase chat\n\nexport const loginAnonymously = async () => {\n  let userInfo = storageService.getItem(\"userInfo\");\n  try {\n    let response = await auth.signInAnonymously();\n    if (response) {\n      console.log(\"firebase anonymous auth login success: \");\n      await db.ref(`${FIREBASE_COLLECTION.USERS}/${userInfo?._id}`).update({\n        email: userInfo?.email,\n        image: userInfo?.user_image,\n        name: userInfo?.userName,\n        userId: userInfo?._id,\n        onlineStatus: true,\n        userType: userInfo?.user_type,\n        deviceType: 1,\n      });\n    }\n  } catch (error) {\n    console.log(\"firebase anonymous auth login failure: \");\n    var errorCode = error.code;\n    if (errorCode === \"auth/operation-not-allowed\") {\n      alert(\"You must enable Anonymous auth in the Firebase Console.\");\n    } else {\n      console.error(error);\n    }\n  }\n};\n\nexport const getLoggedInuserId = () => {\n  return storageService.getItem(\"userInfo\")?._id;\n};\n\nexport const updateChatUserDetails = async (updateType, value) => {\n  let loggedInuserId = getLoggedInuserId();\n  try {\n    await db.ref(`${FIREBASE_COLLECTION.USERS}/${loggedInuserId}`).update({\n      ...(updateType === \"userImage\" && { image: value }),\n      ...(updateType === \"userName\" && { name: value }),\n      ...(updateType === \"deviceToken\" && { deviceToken: value }),\n      ...(updateType === \"isNotification\" && { isNotification: value }),\n    });\n    console.log(`firebase ${updateType} update success`);\n  } catch (err) {\n    console.log(`firebase ${updateType} update failure: `, { err });\n  }\n};\n\nexport const createRoom = async (jobId, tradieId, builderId, jobName) => {\n  let loggedInuserId = getLoggedInuserId();\n\n  const roomID = `${jobId}_${tradieId}_${builderId}`;\n\n  if (await checkRoomExist(roomID)) {\n    return;\n  }\n\n  let roomInfoObj = {\n    id: roomID,\n    chatRoomType: CHAT_TYPE,\n    chatLastUpdate: firebase.database.ServerValue.TIMESTAMP,\n  };\n  let chatLastUpdates = {};\n  chatLastUpdates[tradieId] =\n    tradieId === loggedInuserId ? firebase.database.ServerValue.TIMESTAMP : 0;\n  chatLastUpdates[loggedInuserId] = firebase.database.ServerValue.TIMESTAMP;\n\n  let chatRoomMembers = {};\n  chatRoomMembers[tradieId] = {\n    memberDelete: firebase.database.ServerValue.TIMESTAMP,\n    memberJoin: firebase.database.ServerValue.TIMESTAMP,\n    memberLeave: 0,\n  };\n\n  chatRoomMembers[builderId] = {\n    memberDelete: firebase.database.ServerValue.TIMESTAMP,\n    memberJoin: firebase.database.ServerValue.TIMESTAMP,\n    memberLeave: 0,\n  };\n  roomInfoObj.chatRoomMembers = chatRoomMembers;\n  roomInfoObj.chatLastUpdates = chatLastUpdates;\n\n  await db.ref(`${FIREBASE_COLLECTION.ROOM_INFO}/${roomID}/`).set(roomInfoObj);\n  // debugger;\n  // await createItem(itemInfo);\n  //loggedin user inbox\n  await createInbox(tradieId, roomID, jobId, builderId, jobName);\n  // opposite user inbox\n  await createInbox(builderId, roomID, jobId, tradieId, jobName);\n  return roomInfoObj;\n};\n\nexport const checkRoomExist = async (roomID) => {\n  let room = await db\n    .ref(`${FIREBASE_COLLECTION.ROOM_INFO}/${roomID}/`)\n    .once(\"value\");\n  return room.exists();\n};\n\nexport const createJob = async (jobInfo) => {\n  await db.ref(`${FIREBASE_COLLECTION.JOBS}/${jobInfo.jobId}/`).set(jobInfo);\n};\n\nexport const createInbox = async (\n  userid,\n  roomId,\n  jobId,\n  oppuserid,\n  jobName\n) => {\n  const inboxKey = `${oppuserid}_${jobId}`;\n  await db.ref(`${FIREBASE_COLLECTION.INBOX}/${userid}/${inboxKey}`).set({\n    jobId: jobId,\n    jobName: jobName,\n    roomId: roomId,\n    unreadMessages: 0,\n  });\n};\n\nexport const getFirebaseInboxData = async (listner) => {\n  // debugger;\n  let userId = getLoggedInuserId();\n  if (!userId) {\n    listner([]);\n    return;\n  }\n  let dbRef = `${FIREBASE_COLLECTION.INBOX}/${userId}`;\n  console.log(\"getFirebaseIndexData\", dbRef);\n  if (inboxListner) {\n    db.ref(dbRef).off();\n    db.ref(dbRef).off(\"value\", msgListnerObj);\n  }\n  inboxListner = db.ref(dbRef).on(\"value\", async (snapshot) => {\n    let indexlist = [];\n    snapshot.forEach((snap) => {\n      indexlist.push(snap.val());\n    });\n    let items = [];\n    let users = [];\n    for (let i = 0; i < indexlist.length; i++) {\n      // let itemIndex = items.findIndex((item) => item.jobId === indexlist[i].jobId);\n      // if (itemIndex == -1) {\n      //     let room = await db.ref(`${FIREBASE_COLLECTION.JOBS}/${indexlist[i].jobId}`).once('value');\n      //     if (room.exists()) {\n      //         let lastMsg = await db.ref(`${FIREBASE_COLLECTION.LAST_MESSAGES}/${indexlist[i].roomId}/chatLastMessage`).once('value');\n      //         indexlist[i].item = room.val();\n      //         if (lastMsg.exists())\n      //             indexlist[i].lastMsg = lastMsg.val();\n      //         items.push(room.val());\n      //     }\n      // } else {\n      //     indexlist[i].item = items[itemIndex];\n      // }\n      let lastMsg = await db\n        .ref(\n          `${FIREBASE_COLLECTION.LAST_MESSAGES}/${indexlist[i].roomId}/chatLastMessage`\n        )\n        .once(\"value\");\n      if (lastMsg.exists()) {\n        indexlist[i].lastMsg = lastMsg.val();\n      }\n      let oppUserId = \"\";\n      if (storageService.getItem(\"userType\") === 1) {\n        oppUserId = indexlist[i].roomId.split(\"_\")[2];\n      } else {\n        oppUserId = indexlist[i].roomId.split(\"_\")[1];\n      }\n      let userIndex = users.findIndex((item) => item.userId === oppUserId);\n      if (userIndex == -1) {\n        let oppUserInfo = await db\n          .ref(`${FIREBASE_COLLECTION.USERS}/${oppUserId}`)\n          .once(\"value\");\n        if (oppUserInfo.exists()) {\n          indexlist[i].oppUserInfo = oppUserInfo.val();\n          users.push(oppUserInfo.val());\n        }\n      } else {\n        indexlist[i].oppUserInfo = users[userIndex];\n      }\n    }\n    setPendingCounter(indexlist);\n    await listner(indexlist);\n  });\n};\nexport const getFirebaseInboxDataForUnreadMsgCount = async (listner) => {\n  // debugger;\n  let userId = getLoggedInuserId();\n  if (!userId) {\n    listner([]);\n    return;\n  }\n  let dbRef = `${FIREBASE_COLLECTION.INBOX}/${userId}`;\n  console.log(\"getFirebaseIndexData\", dbRef);\n \n  inboxListner = db.ref(dbRef).on(\"value\", async (snapshot) => {\n    let indexlist = [];\n    snapshot.forEach((snap) => {\n      indexlist.push(snap.val());\n    });\n    let items = [];\n    let users = [];\n    for (let i = 0; i < indexlist.length; i++) {\n      // let itemIndex = items.findIndex((item) => item.jobId === indexlist[i].jobId);\n      // if (itemIndex == -1) {\n      //     let room = await db.ref(`${FIREBASE_COLLECTION.JOBS}/${indexlist[i].jobId}`).once('value');\n      //     if (room.exists()) {\n      //         let lastMsg = await db.ref(`${FIREBASE_COLLECTION.LAST_MESSAGES}/${indexlist[i].roomId}/chatLastMessage`).once('value');\n      //         indexlist[i].item = room.val();\n      //         if (lastMsg.exists())\n      //             indexlist[i].lastMsg = lastMsg.val();\n      //         items.push(room.val());\n      //     }\n      // } else {\n      //     indexlist[i].item = items[itemIndex];\n      // }\n      let lastMsg = await db\n        .ref(\n          `${FIREBASE_COLLECTION.LAST_MESSAGES}/${indexlist[i].roomId}/chatLastMessage`\n        )\n        .once(\"value\");\n      if (lastMsg.exists()) {\n        indexlist[i].lastMsg = lastMsg.val();\n      }\n      let oppUserId = \"\";\n      if (storageService.getItem(\"userType\") === 1) {\n        oppUserId = indexlist[i].roomId.split(\"_\")[2];\n      } else {\n        oppUserId = indexlist[i].roomId.split(\"_\")[1];\n      }\n      let userIndex = users.findIndex((item) => item.userId === oppUserId);\n      if (userIndex == -1) {\n        let oppUserInfo = await db\n          .ref(`${FIREBASE_COLLECTION.USERS}/${oppUserId}`)\n          .once(\"value\");\n        if (oppUserInfo.exists()) {\n          indexlist[i].oppUserInfo = oppUserInfo.val();\n          users.push(oppUserInfo.val());\n        }\n      } else {\n        indexlist[i].oppUserInfo = users[userIndex];\n      }\n    }\n    setPendingCounter(indexlist);\n    await listner(indexlist);\n  });\n};\n\nexport const setPendingCounter = (indexlist) => {\n  let count = 0;\n  let unreadMsg = indexlist.filter((d) => d.unreadMessages > 0);\n  unreadMsg.length === 0 ? (count = 0) : (count = unreadMsg.length);\n  // store.dispatch({\n  //     type: INBOX_COUNTER_SET,\n  //     payLoad: count\n  // });\n};\n\n// export const getFirebaseItemsData = async () => {\n//     let itemlist = [];\n//     db.ref(`${FIREBASE_COLLECTION.JOBS}`).on(\"value\", (snapshot) => {\n//         snapshot.forEach((snap) => {\n//             itemlist.push(snap.val());\n//         });\n//     });\n//     return itemlist;\n// }\n\n// export const getFirebaseRoomInfoData = async () => {\n//     let roomlist = [];\n//     db.ref(`${FIREBASE_COLLECTION.ROOM_INFO}`).on(\"value\", (snapshot) => {\n//         snapshot.forEach((snap) => {\n//             roomlist.push(snap.val());\n//         });\n//     });\n//     return roomlist\n// }\n\nexport const getMessagesOfRoom = async (roomId, listner) => {\n  //getPreviousMessages check KT file\n  //.limitToLast(10)\n\n  // if (msgListnerObj) {\n  //     await db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`).off('value', msgListnerObj);\n  // }\n\n  msgListnerObj = db\n    .ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`)\n    .orderByChild(\"messageTimestamp\")\n    .limitToLast(500)\n    .on(\"value\", (snapshot) => {\n      let itemlist = [];\n      snapshot.forEach((snap) => {\n        itemlist.push(snap.val());\n      });\n      listner(itemlist);\n    });\n};\n\nexport const stopListeningOfRoom = async (roomId) => {\n  if (msgListnerObj) {\n    db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`).off(\n      \"value\",\n      msgListnerObj\n    );\n    db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`).off();\n  }\n  console.log(\"Stop listening Of Room\");\n};\n\nexport const sendTextMessage = async (roomId, message) => {\n  let senderId = getLoggedInuserId();\n  let roomids = roomId.split(\"_\");\n  let jobId = \"\";\n  let receiverId = \"\";\n  if (roomids.length == 3) {\n    if (roomids[1] == senderId) {\n      receiverId = roomids[2];\n    } else {\n      receiverId = roomids[1];\n    }\n    jobId = roomids[0];\n  }\n\n  let dbRef = db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`);\n  const newMsgRef = dbRef.push();\n  // Get the unique key generated by push()\n  const messageID = newMsgRef.key;\n\n  let msgData = {\n    isBlock: false,\n    isDeleted: false,\n    mediaDuration: \"\",\n    mediaUrl: \"\",\n    messageCaption: \"\",\n    messageId: messageID,\n    messageRoomId: roomId,\n    messageStatus: \"send\",\n    messageText: message,\n    messageTimestamp: firebase.database.ServerValue.TIMESTAMP,\n    messageType: \"text\",\n    progress: 0,\n    receiverId: receiverId,\n    senderId: senderId,\n    thumbnail: \"\",\n  };\n  await db\n    .ref(`${FIREBASE_COLLECTION.LAST_MESSAGES}/${roomId}/chatLastMessage`)\n    .set(msgData);\n  await db\n    .ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}/${messageID}`)\n    .set(msgData);\n  msgData.messageTimestamp = moment().toDate().getTime();\n\n  //TODO Implement Update Message Counter\n  //https://stackoverflow.com/questions/42276881/increment-firebase-value-from-javascript-subject-to-constraint\n  let inboxId = `${senderId}_${jobId}`;\n  await db\n    .ref(`${FIREBASE_COLLECTION.INBOX}/${receiverId}/${inboxId}`)\n    .child(\"unreadMessages\")\n    .set(firebase.database.ServerValue.increment(1));\n  return msgData;\n};\n\nexport const sendImageVideoMessage = async (roomId, url, type) => {\n  let senderId = getLoggedInuserId();\n  let roomids = roomId.split(\"_\");\n  let jobId = \"\";\n  let receiverId = \"\";\n  if (roomids.length == 3) {\n    if (roomids[1] == senderId) {\n      receiverId = roomids[2];\n    } else {\n      receiverId = roomids[1];\n    }\n    jobId = roomids[0];\n  }\n\n  let dbRef = db.ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}`);\n  const newMsgRef = dbRef.push();\n  // Get the unique key generated by push()\n  const messageID = newMsgRef.key;\n\n  let msgData = {\n    isBlock: false,\n    isDeleted: false,\n    mediaDuration: \"\",\n    mediaUrl: url,\n    messageCaption: \"\",\n    messageId: messageID,\n    messageRoomId: roomId,\n    messageStatus: \"send\",\n    messageText: \"\",\n    messageTimestamp: firebase.database.ServerValue.TIMESTAMP,\n    messageType: type === \"image\" ? \"image\" : \"video\",\n    progress: 0,\n    receiverId: receiverId,\n    senderId: senderId,\n    thumbnail: url,\n  };\n  await db\n    .ref(`${FIREBASE_COLLECTION.LAST_MESSAGES}/${roomId}/chatLastMessage`)\n    .set(msgData);\n  await db\n    .ref(`${FIREBASE_COLLECTION.MESSAGES}/${roomId}/${messageID}`)\n    .set(msgData);\n  msgData.messageTimestamp = moment().toDate().getTime();\n\n  //Implement Update Message Counter\n  //https://stackoverflow.com/questions/42276881/increment-firebase-value-from-javascript-subject-to-constraint\n  let inboxId = `${senderId}_${jobId}`;\n  await db\n    .ref(`${FIREBASE_COLLECTION.INBOX}/${receiverId}/${inboxId}`)\n    .child(\"unreadMessages\")\n    .set(firebase.database.ServerValue.increment(1));\n  return msgData;\n};\n\nexport const resetUnreadCounter = async (roomId) => {\n  let senderId = getLoggedInuserId();\n  let roomids = roomId.split(\"_\");\n  let jobId = \"\";\n  let receiverId = \"\";\n  if (roomids.length === 3) {\n    if (roomids[1] == senderId) {\n      receiverId = roomids[2];\n    } else {\n      receiverId = roomids[1];\n    }\n    jobId = roomids[0];\n  }\n  let inboxId = `${receiverId}_${jobId}`;\n  await db\n    .ref(`${FIREBASE_COLLECTION.INBOX}/${senderId}/${inboxId}`)\n    .child(\"unreadMessages\")\n    .set(0);\n};\n\nexport default firebase;\n"]},"metadata":{},"sourceType":"module"}