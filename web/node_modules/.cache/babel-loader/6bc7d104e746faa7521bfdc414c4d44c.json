{"ast":null,"code":"import { get } from 'lodash';\nimport { setShowToast } from '../redux/common/actions';\nimport storageService from '../utils/storageService';\nimport { urlFor } from './Urls';\nimport Constants from '../utils/constants';\nimport * as moment from 'moment';\nimport 'moment-timezone';\n\nclass NetworkOps {\n  constructor() {\n    this.postToJson = async (service, data) => {\n      try {\n        const JSONData = JSON.stringify(data);\n        return this.postRaw(service, JSONData);\n      } catch (err) {\n        throw err;\n      }\n    };\n\n    this.postRaw = async (service, data, options) => {\n      try {\n        const request = await this.getRequest('POST', options);\n        request.body = data;\n        return this.wrapperWithOptions(urlFor(service), request);\n      } catch (err) {\n        throw err;\n      }\n    };\n\n    this.putToJson = async (service, data) => {\n      try {\n        const request = await this.getRequest('PUT');\n        request.body = JSON.stringify(data);\n        return this.wrapperWithOptions(urlFor(service), request);\n      } catch (err) {\n        throw err;\n      }\n    };\n\n    this.putRaw = async (service, data, options) => {\n      try {\n        const request = await this.getRequest('PUT', options);\n        request.body = data;\n        return this.wrapperWithOptions(urlFor(service), request);\n      } catch (err) {\n        throw err;\n      }\n    };\n\n    this.get = async service => {\n      try {\n        const request = await this.getRequest('GET');\n        return await this.wrapperWithOptions(urlFor(service), request);\n      } catch (err) {\n        throw err;\n      }\n    };\n\n    this.delete = async (service, data) => {\n      try {\n        const request = await this.getRequest('DELETE');\n        request.body = JSON.stringify(data);\n        return this.wrapperWithOptions(urlFor(service), request);\n      } catch (err) {\n        throw err;\n      }\n    };\n\n    this.getRaw = async service => {\n      try {\n        const request = await this.getRequest('GET');\n        return this.wrapperWithOptions(service, request);\n      } catch (err) {\n        throw err;\n      }\n    };\n  }\n\n  async getRequest(type, options) {\n    const headerOverrides = get(options, 'headerOverrides', {});\n    const request = {\n      method: type,\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Basic ${Constants.BasicAuthorizationToken}`,\n        'timezone': moment.tz.guess(),\n        ...headerOverrides\n      }\n    }; //if giving multipart/form-data in Content-Type: giving boundary error\n    //if also adding boundary: loader continues from server end \n\n    const token = storageService.getItem('jwtToken');\n\n    if (headerOverrides['Content-Type'] === 'multipart/form-data') {\n      delete request.headers['Content-Type'];\n    }\n\n    if (token) {\n      request.headers = { ...request.headers,\n        Authorization: token,\n        'timezone': moment.tz.guess() // Authorization: `Bearer ${token}`,\n\n      };\n    }\n\n    return request;\n  }\n\n  async wrapperWithOptions(url, request) {\n    try {\n      const response = await fetch(url, request);\n\n      if (!response.ok) {\n        if (response.status === 401) {\n          if (storageService.getItem('jwtToken')) {\n            storageService.clearAll();\n            const res1 = await response.text();\n            const res2 = JSON.parse(res1);\n            setShowToast(true, res2.message || 'You\\'ve been logged out');\n            setTimeout(() => {\n              window.location.pathname = '/login';\n            }, 1000);\n            return;\n          }\n        } else if (response.status === 500 || response.status === 400) {\n          console.log('Got 401, now calling logout', response);\n        }\n\n        const err = await response.json();\n        console.log('Error -> ', err);\n        throw err;\n      } else {\n        const res = await response.text();\n\n        try {\n          return JSON.parse(res);\n        } catch {\n          return res;\n        }\n      }\n    } catch (error) {\n      console.log('Error', error);\n      return error;\n    }\n  }\n\n}\n\nexport default new NetworkOps();","map":{"version":3,"sources":["/home/appinventiv/Documents/Project/tickt/web/src/network/NetworkOps.ts"],"names":["get","setShowToast","storageService","urlFor","Constants","moment","NetworkOps","postToJson","service","data","JSONData","JSON","stringify","postRaw","err","options","request","getRequest","body","wrapperWithOptions","putToJson","putRaw","delete","getRaw","type","headerOverrides","method","headers","Authorization","BasicAuthorizationToken","tz","guess","token","getItem","url","response","fetch","ok","status","clearAll","res1","text","res2","parse","message","setTimeout","window","location","pathname","console","log","json","res","error"],"mappings":"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","sourcesContent":["import { get } from 'lodash';\nimport { setShowToast } from '../redux/common/actions';\nimport storageService from '../utils/storageService';\nimport { urlFor } from './Urls';\nimport Constants from '../utils/constants';\nimport * as moment from 'moment';\nimport 'moment-timezone';\n\nexport interface FetchResponse {\n    status?: number | boolean,\n    status_code?: number\n    message: string,\n    result: any,\n    data: any\n}\n\nclass NetworkOps {\n\n    async getRequest(type: string, options?: object): Promise<any> {\n        const headerOverrides = get(options, 'headerOverrides', {});\n        const request = {\n            method: type,\n            headers: {\n                'Content-Type': 'application/json',\n                Authorization: `Basic ${Constants.BasicAuthorizationToken}`,\n                'timezone': moment.tz.guess(),\n                ...headerOverrides\n            },\n        };\n\n        //if giving multipart/form-data in Content-Type: giving boundary error\n        //if also adding boundary: loader continues from server end \n        const token = storageService.getItem('jwtToken');\n        if (headerOverrides['Content-Type'] === 'multipart/form-data') {\n            delete request.headers['Content-Type'];\n        }\n        if (token) {\n            request.headers = {\n                ...request.headers,\n                Authorization: token,\n                'timezone': moment.tz.guess(),\n                // Authorization: `Bearer ${token}`,\n            }\n        }\n        return request;\n    }\n\n    async wrapperWithOptions(url: string, request: any) {\n        try {\n            const response: any = await fetch(url, request);\n            if (!response.ok) {\n                if (response.status === 401) {\n                    if (storageService.getItem('jwtToken')) {\n                        storageService.clearAll();\n                        const res1 = await response.text();\n                        const res2 = JSON.parse(res1);\n                        setShowToast(true, res2.message || 'You\\'ve been logged out');\n                        setTimeout(() => {\n                            window.location.pathname = '/login';\n                        }, 1000);\n                        return;\n                    }\n                }\n                else if (response.status === 500 || response.status === 400) {\n                    console.log('Got 401, now calling logout', response);\n                }\n                const err = await response.json();\n                console.log('Error -> ', err)\n                throw err;\n            }\n            else {\n                const res = await response.text();\n                try {\n                    return JSON.parse(res);\n                }\n                catch {\n                    return res;\n                }\n            }\n        }\n        catch (error) {\n            console.log('Error', error);\n            return error;\n        }\n    }\n\n    postToJson = async (service: string, data: any): Promise<FetchResponse> => {\n        try {\n            const JSONData = JSON.stringify(data);\n            return this.postRaw(service, JSONData)\n        }\n        catch (err) {\n            throw err;\n        }\n    }\n\n    postRaw = async (service: string, data: any, options?: any): Promise<FetchResponse> => {\n        try {\n            const request = await this.getRequest('POST', options);\n            request.body = data;\n            return this.wrapperWithOptions(urlFor(service), request)\n        }\n        catch (err) {\n            throw err;\n        }\n    }\n\n    putToJson = async (service: string, data: any): Promise<FetchResponse> => {\n        try {\n            const request = await this.getRequest('PUT');\n            request.body = JSON.stringify(data);\n            return this.wrapperWithOptions(urlFor(service), request)\n        }\n        catch (err) {\n            throw err;\n        }\n    }\n\n    putRaw = async (service: string, data: any, options?: any): Promise<FetchResponse> => {\n        try {\n            const request = await this.getRequest('PUT', options);\n            request.body = data\n            return this.wrapperWithOptions(urlFor(service), request)\n        }\n        catch (err) {\n            throw err;\n        }\n    }\n\n    get = async (service: any): Promise<FetchResponse> => {\n        try {\n            const request = await this.getRequest('GET');\n            return await this.wrapperWithOptions(urlFor(service), request);\n        }\n        catch (err) {\n            throw err;\n        }\n    }\n\n    delete = async (service: string, data?: any): Promise<FetchResponse> => {\n        try {\n            const request = await this.getRequest('DELETE');\n            request.body = JSON.stringify(data);\n            return this.wrapperWithOptions(urlFor(service), request)\n        }\n        catch (err) {\n            throw err;\n        }\n    }\n\n    getRaw = async (service: string): Promise<any> => {\n        try {\n            const request = await this.getRequest('GET');\n            return this.wrapperWithOptions(service, request)\n        }\n        catch (err) {\n            throw err;\n        }\n    }\n}\n\nexport default new NetworkOps();"]},"metadata":{},"sourceType":"module"}